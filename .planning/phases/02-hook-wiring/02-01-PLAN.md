---
phase: 02-hook-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/register-hooks.sh
autonomous: true
requirements: [CONFIG-03]

must_haves:
  truths:
    - "Stop hook registered in ~/.claude/settings.json calling stop-hook.sh"
    - "Notification hook registered with matcher 'idle_prompt' calling notification-idle-hook.sh"
    - "Notification hook registered with matcher 'permission_prompt' calling notification-permission-hook.sh"
    - "SessionEnd hook registered with no matcher calling session-end-hook.sh"
    - "PreCompact hook registered with no matcher calling pre-compact-hook.sh"
    - "gsd-session-hook.sh removed from SessionStart hooks array"
    - "gsd-check-update.js preserved in SessionStart hooks array"
    - "Registration script is idempotent (safe to run multiple times with same result)"
  artifacts:
    - path: "scripts/register-hooks.sh"
      provides: "Idempotent hook registration into settings.json"
      min_lines: 60
      exports: []
  key_links:
    - from: "scripts/register-hooks.sh"
      to: "~/.claude/settings.json"
      via: "jq merge with atomic file replacement"
      pattern: "jq.*argjson.*settings.json"
    - from: "scripts/register-hooks.sh"
      to: "scripts/stop-hook.sh"
      via: "absolute path in hook command field"
      pattern: "stop-hook\\.sh"
    - from: "scripts/register-hooks.sh"
      to: "scripts/notification-idle-hook.sh"
      via: "absolute path in hook command field"
      pattern: "notification-idle-hook\\.sh"
    - from: "scripts/register-hooks.sh"
      to: "scripts/notification-permission-hook.sh"
      via: "absolute path in hook command field"
      pattern: "notification-permission-hook\\.sh"
    - from: "scripts/register-hooks.sh"
      to: "scripts/session-end-hook.sh"
      via: "absolute path in hook command field"
      pattern: "session-end-hook\\.sh"
    - from: "scripts/register-hooks.sh"
      to: "scripts/pre-compact-hook.sh"
      via: "absolute path in hook command field"
      pattern: "pre-compact-hook\\.sh"
---

<objective>
Wire all 5 hook scripts into Claude Code's native hook system by creating an idempotent registration script and executing it against ~/.claude/settings.json.

Purpose: Enable event-driven agent control -- new Claude Code sessions fire Stop, Notification (idle/permission), SessionEnd, and PreCompact hooks instead of relying on the obsolete SessionStart-based hook-watcher polling system.

Output: scripts/register-hooks.sh (idempotent registration utility), updated ~/.claude/settings.json with all hooks registered and gsd-session-hook.sh removed from SessionStart.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-hook-wiring/02-RESEARCH.md

# Phase 1 summaries needed -- hook scripts were created there, we reference their paths
@.planning/phases/01-additive-changes/01-02-SUMMARY.md
@.planning/phases/01-additive-changes/01-03-SUMMARY.md

# Current settings.json to understand existing structure
@~/.claude/settings.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create idempotent hook registration script</name>
  <files>scripts/register-hooks.sh</files>
  <action>
Create scripts/register-hooks.sh -- an idempotent bash script that registers all 5 hook events in ~/.claude/settings.json and removes gsd-session-hook.sh from SessionStart.

Script structure:
1. Standard header: `#!/usr/bin/env bash` + `set -euo pipefail`
2. Log function with timestamps: `printf '[%s] %s\n' "$(date -u +'%Y-%m-%dT%H:%M:%SZ')" "$*"`
3. Constants:
   - `SETTINGS_FILE="$HOME/.claude/settings.json"`
   - `SKILL_ROOT` resolved from script location: `SKILL_ROOT="$(cd "$(dirname "$0")/.." && pwd)"` (this gives the gsd-code-skill directory)
4. Pre-flight checks:
   - Verify jq is installed (`command -v jq` or exit with error)
   - Verify settings.json exists (if not, create minimal `{}` and log warning)
   - Verify all 5 hook scripts exist at `$SKILL_ROOT/scripts/` (stop-hook.sh, notification-idle-hook.sh, notification-permission-hook.sh, session-end-hook.sh, pre-compact-hook.sh) -- exit with error if any missing
5. Backup: `cp "$SETTINGS_FILE" "${SETTINGS_FILE}.backup-$(date +%s)"` with log message
6. Build the complete hooks configuration as a jq-compatible JSON string in a variable `HOOKS_CONFIG`. Use absolute paths constructed from `$SKILL_ROOT/scripts/`:

   Hook registrations (per research Pattern 1-4):
   - **Stop**: No matcher. Command: `$SKILL_ROOT/scripts/stop-hook.sh`. Timeout: 600.
   - **Notification** (two matcher groups in one array):
     - matcher: `idle_prompt`, command: `$SKILL_ROOT/scripts/notification-idle-hook.sh`, timeout: 600
     - matcher: `permission_prompt`, command: `$SKILL_ROOT/scripts/notification-permission-hook.sh`, timeout: 600
   - **SessionEnd**: No matcher (fires on ALL exit reasons per user decision). Command: `$SKILL_ROOT/scripts/session-end-hook.sh`. No timeout field (use default).
   - **PreCompact**: No matcher (match both auto and manual per discretion decision). Command: `$SKILL_ROOT/scripts/pre-compact-hook.sh`. Timeout: 600.

7. Merge using jq (per research Pattern 6):
   ```
   jq --argjson new "$HOOKS_CONFIG" '
     .hooks = (.hooks // {}) |
     .hooks.Stop = $new.Stop |
     .hooks.Notification = $new.Notification |
     .hooks.SessionEnd = $new.SessionEnd |
     .hooks.PreCompact = $new.PreCompact |
     .hooks.SessionStart = (
       if .hooks.SessionStart then
         [.hooks.SessionStart[] | .hooks |= map(select(.command | contains("gsd-session-hook.sh") | not))]
       else
         []
       end
     )
   ' "$SETTINGS_FILE" > "${SETTINGS_FILE}.tmp"
   ```

   The SessionStart cleanup uses a conditional to avoid errors if SessionStart does not exist. It filters out any hook whose command contains "gsd-session-hook.sh" while keeping everything else (gsd-check-update.js).

8. Validate the output: `jq empty "${SETTINGS_FILE}.tmp"` -- if invalid JSON, log error, remove tmp file, exit 1
9. Atomic replace: `mv "${SETTINGS_FILE}.tmp" "$SETTINGS_FILE"`
10. Verification output: After writing, read back settings.json and print a summary showing each registered hook event and its command path. Also confirm gsd-session-hook.sh is NOT present in SessionStart. Use jq queries for this.
11. Final message: Log that hooks are registered and that Claude Code sessions must be restarted to activate new hooks.

Make the script executable: `chmod +x scripts/register-hooks.sh`

IMPORTANT per user decisions:
- SessionEnd has NO matcher (fires on ALL exit reasons)
- Keep gsd-check-update.js in SessionStart -- only remove gsd-session-hook.sh
- No new SessionStart hook registration
- All hook commands use absolute paths (not relative)

Per discretion decisions:
- PreCompact: no matcher (both auto and manual)
- Stop: async omitted (defaults to false = synchronous)
- Timeouts: 600s for Stop/Notification/PreCompact, default for SessionEnd
  </action>
  <verify>
Run `bash -n scripts/register-hooks.sh` to verify syntax. Run `ls -la scripts/register-hooks.sh` to confirm executable permissions. Grep the script to confirm all 5 hook script paths are referenced and "gsd-session-hook.sh" removal logic exists.
  </verify>
  <done>
scripts/register-hooks.sh exists, passes bash syntax check, is executable, references all 5 hook scripts by absolute path, includes gsd-session-hook.sh removal logic, creates backup before modifying, validates JSON output, and uses atomic file replacement.
  </done>
</task>

<task type="auto">
  <name>Task 2: Execute registration and verify settings.json</name>
  <files></files>
  <action>
Run the registration script against the live ~/.claude/settings.json:

```bash
bash scripts/register-hooks.sh
```

After execution, verify the result by querying settings.json with jq:

1. Confirm Stop hook registered:
   `jq '.hooks.Stop[0].hooks[0].command' ~/.claude/settings.json`
   Expected: path ending in stop-hook.sh

2. Confirm Notification hooks registered with correct matchers:
   `jq '.hooks.Notification[] | {matcher, command: .hooks[0].command}' ~/.claude/settings.json`
   Expected: idle_prompt -> notification-idle-hook.sh, permission_prompt -> notification-permission-hook.sh

3. Confirm SessionEnd hook registered (no matcher):
   `jq '.hooks.SessionEnd[0].hooks[0].command' ~/.claude/settings.json`
   Expected: path ending in session-end-hook.sh

4. Confirm PreCompact hook registered (no matcher):
   `jq '.hooks.PreCompact[0].hooks[0].command' ~/.claude/settings.json`
   Expected: path ending in pre-compact-hook.sh

5. Confirm gsd-session-hook.sh REMOVED from SessionStart:
   `jq '[.hooks.SessionStart[].hooks[].command] | map(select(contains("gsd-session-hook.sh")))' ~/.claude/settings.json`
   Expected: empty array `[]`

6. Confirm gsd-check-update.js PRESERVED in SessionStart:
   `jq '[.hooks.SessionStart[].hooks[].command] | map(select(contains("gsd-check-update.js")))' ~/.claude/settings.json`
   Expected: array with one entry containing gsd-check-update.js

7. Confirm overall JSON is valid:
   `jq empty ~/.claude/settings.json`
   Expected: exit code 0

8. Confirm non-hook settings preserved (statusLine, enabledPlugins, skipDangerousModePermissionPrompt):
   `jq 'keys' ~/.claude/settings.json`
   Expected: contains hooks, statusLine, enabledPlugins, skipDangerousModePermissionPrompt

9. Run the script a SECOND time to confirm idempotency -- settings.json should have identical hook structure after re-run (use `jq '.hooks' ~/.claude/settings.json` before and after, diff should be empty).

If any verification fails, fix the register-hooks.sh script and re-run.
  </action>
  <verify>
All 9 verification queries above produce expected results. settings.json is valid JSON with all 5 hook events registered, gsd-session-hook.sh removed, gsd-check-update.js preserved, and non-hook settings intact.
  </verify>
  <done>
~/.claude/settings.json contains all 5 hook registrations (Stop, Notification idle_prompt, Notification permission_prompt, SessionEnd, PreCompact), gsd-session-hook.sh is removed from SessionStart, gsd-check-update.js is preserved, all other settings are unchanged, and the registration script is confirmed idempotent.
  </done>
</task>

</tasks>

<verification>
Phase 2 success criteria from ROADMAP.md:

1. Stop hook registered in ~/.claude/settings.json calling stop-hook.sh
   - Verify: `jq '.hooks.Stop[0].hooks[0].command' ~/.claude/settings.json` contains "stop-hook.sh"

2. Notification hooks registered with matchers for idle_prompt and permission_prompt
   - Verify: `jq '.hooks.Notification | length' ~/.claude/settings.json` equals 2
   - Verify: matchers are exactly "idle_prompt" and "permission_prompt"

3. SessionEnd hook registered calling session-end-hook.sh
   - Verify: `jq '.hooks.SessionEnd[0].hooks[0].command' ~/.claude/settings.json` contains "session-end-hook.sh"

4. PreCompact hook registered calling pre-compact-hook.sh
   - Verify: `jq '.hooks.PreCompact[0].hooks[0].command' ~/.claude/settings.json` contains "pre-compact-hook.sh"

5. gsd-session-hook.sh removed from SessionStart hooks array in settings.json
   - Verify: No command in SessionStart contains "gsd-session-hook.sh"

6. New Claude Code sessions fire all hooks instead of spawning hook-watcher.sh
   - Verify: settings.json structure correct (hooks snapshot at session start)

7. Existing sessions with running hook-watcher continue working (brief overlap tolerated)
   - Verify: No running sessions were modified (hooks only apply to new sessions)
</verification>

<success_criteria>
- scripts/register-hooks.sh exists, is executable, and passes bash -n syntax check
- Running register-hooks.sh produces valid settings.json with all 5 hook events
- gsd-session-hook.sh absent from SessionStart hooks
- gsd-check-update.js present in SessionStart hooks
- Non-hook settings (statusLine, enabledPlugins, skipDangerousModePermissionPrompt) unchanged
- Script is idempotent: second run produces identical hooks structure
- Backup file created before each run
</success_criteria>

<output>
After completion, create `.planning/phases/02-hook-wiring/02-01-SUMMARY.md`
</output>
