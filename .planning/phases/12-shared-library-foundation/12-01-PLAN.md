---
phase: 12-shared-library-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/hook-preamble.sh
  - lib/hook-utils.sh
autonomous: true
requirements:
  - REFAC-01
  - REFAC-02
  - REFAC-04
  - REFAC-05

must_haves:
  truths:
    - "Sourcing lib/hook-preamble.sh from a test caller sets HOOK_SCRIPT_NAME to the test caller's basename, not 'hook-preamble.sh'"
    - "Running 'bash lib/hook-preamble.sh' directly prints an error and exits non-zero"
    - "Sourcing lib/hook-preamble.sh twice from the same caller is harmless (source guard prevents re-execution)"
    - "After sourcing lib/hook-preamble.sh, all lib/hook-utils.sh functions are callable without additional source statements"
    - "extract_hook_settings() returns correct JSON with three-tier fallback (per-agent > global > hardcoded defaults)"
    - "detect_session_state() returns consistent state names (menu, permission_prompt, idle, error, working) using case-insensitive matching"
  artifacts:
    - path: "lib/hook-preamble.sh"
      provides: "Shared bootstrap for all hook scripts — source guard, direct-exec guard, BASH_SOURCE[1] identity, debug_log, hook-utils sourcing"
      contains: "BASH_SOURCE[1]"
    - path: "lib/hook-utils.sh"
      provides: "extract_hook_settings() and detect_session_state() shared functions"
      contains: "extract_hook_settings"
  key_links:
    - from: "lib/hook-preamble.sh"
      to: "lib/hook-utils.sh"
      via: "source statement using _GSD_PREAMBLE_LIB_DIR"
      pattern: "source.*_GSD_PREAMBLE_LIB_DIR.*hook-utils\\.sh"
    - from: "lib/hook-preamble.sh"
      to: "HOOK_SCRIPT_NAME"
      via: "BASH_SOURCE[1] basename"
      pattern: "basename.*BASH_SOURCE\\[1\\]"
---

<objective>
Create the shared library foundation for hook refactoring: lib/hook-preamble.sh (new file) and two new functions in lib/hook-utils.sh (extract_hook_settings, detect_session_state). These are stable, tested interfaces that Phase 13 will use to refactor all 7 hook scripts. No hook scripts are modified in this plan.

Purpose: Eliminate the 27-line duplicated bootstrap block (7 hooks), the 12-line duplicated settings extraction (4 hooks), and the divergent state detection (2 implementations) by creating shared, tested library code first.

Output: Two library files ready for consumption by Phase 13.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-shared-library-foundation/12-RESEARCH.md
@lib/hook-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/hook-preamble.sh with source guard, direct-exec guard, and BASH_SOURCE[1] identity</name>
  <files>lib/hook-preamble.sh</files>
  <action>
Create a new file `lib/hook-preamble.sh`. This is the extracted 27-line bootstrap block that all 7 hook scripts currently duplicate. The preamble is sourced (never executed directly) as the first action of every hook script.

**Critical implementation details (from research):**

1. **Source guard** (REFAC-02): At the very top, check `[[ -n "${_GSD_HOOK_PREAMBLE_LOADED:-}" ]] && return 0`. Then set `readonly _GSD_HOOK_PREAMBLE_LOADED=1`. This prevents double-sourcing and is idempotent.

2. **Direct execution guard** (REFAC-02): After source guard, check `if [[ "${BASH_SOURCE[0]}" == "${0}" ]]`. When executed directly, BASH_SOURCE[0] equals $0. When sourced, they differ. Print error to stderr and `exit 1`.

3. **BASH_SOURCE[1] for identity** (REFAC-01): This is the highest-risk point. Inside a sourced preamble:
   - `BASH_SOURCE[0]` = path to hook-preamble.sh itself (WRONG for identity)
   - `BASH_SOURCE[1]` = path to the calling hook script (CORRECT for identity)
   Use `BASH_SOURCE[1]` for HOOK_SCRIPT_NAME and SCRIPT_DIR.

4. **Path resolution**: Resolve `_GSD_PREAMBLE_LIB_DIR` from `BASH_SOURCE[0]` (preamble's own location). Compute `_GSD_SKILL_ROOT` as one directory up from lib/. Set `SKILL_LOG_DIR`, `REGISTRY_PATH`, `GSD_HOOK_LOG` from skill root.

5. **debug_log() function**: Define `debug_log()` that prepends timestamp and HOOK_SCRIPT_NAME, appends to GSD_HOOK_LOG. Fire an initial "FIRED" log entry.

6. **Source hook-utils.sh**: Source `${_GSD_PREAMBLE_LIB_DIR}/hook-utils.sh`. If file missing, log FATAL and `exit 0` (this is the ONLY exit statement besides the direct-exec guard). Use shellcheck directive for source path.

**What NOT to include in preamble:**
- No `set -euo pipefail` (inherits from caller)
- No stdin consumption (`STDIN_JSON=$(cat)` must stay in hook body)
- No `HOOK_ENTRY_MS` (timing starts in hook body after source returns)
- No multiple exit statements (exactly one `exit 0` for lib-missing, one `exit 1` for direct-exec)

**Shebang**: Include `#!/usr/bin/env bash` for editor tooling but the file is never executed directly.

The complete implementation is provided in the research file under "Pattern 1: Sourced Preamble via BASH_SOURCE[1]". Follow that implementation exactly. The file should be approximately 30-40 lines including comments.

Make the file executable: `chmod +x lib/hook-preamble.sh`.
  </action>
  <verify>
Run these verification checks:

```bash
# 1. File exists and is executable
test -x lib/hook-preamble.sh && echo "PASS: executable" || echo "FAIL: not executable"

# 2. Direct execution guard works (should exit 1 with error message)
bash lib/hook-preamble.sh 2>&1 | grep -q "must be sourced" && echo "PASS: direct-exec guard" || echo "FAIL: direct-exec guard"

# 3. Contains BASH_SOURCE[1] for identity (not BASH_SOURCE[0])
grep -q 'BASH_SOURCE\[1\]' lib/hook-preamble.sh && echo "PASS: uses BASH_SOURCE[1]" || echo "FAIL: missing BASH_SOURCE[1]"

# 4. Source guard sentinel exists
grep -q '_GSD_HOOK_PREAMBLE_LOADED' lib/hook-preamble.sh && echo "PASS: source guard" || echo "FAIL: source guard"

# 5. Sources hook-utils.sh
grep -q 'source.*hook-utils.sh' lib/hook-preamble.sh && echo "PASS: sources hook-utils" || echo "FAIL: missing hook-utils source"
```
  </verify>
  <done>lib/hook-preamble.sh exists, is executable, rejects direct execution with a clear error, uses BASH_SOURCE[1] for HOOK_SCRIPT_NAME, includes source guard with _GSD_HOOK_PREAMBLE_LOADED sentinel, and sources lib/hook-utils.sh from its own directory</done>
</task>

<task type="auto">
  <name>Task 2: Add extract_hook_settings() and detect_session_state() to lib/hook-utils.sh</name>
  <files>lib/hook-utils.sh</files>
  <action>
Append two new functions to the END of `lib/hook-utils.sh` (after the existing `deliver_async_with_logging()` function). Do NOT modify any existing functions. The file's "no side effects on source" contract must be preserved.

**Function 1: extract_hook_settings()** (REFAC-04)

Replaces the 12-line settings extraction block duplicated in stop-hook.sh, notification-idle-hook.sh, notification-permission-hook.sh, and pre-compact-hook.sh.

Arguments:
- `$1` - registry_path: path to recovery-registry.json
- `$2` - agent_data_json: JSON string from lookup_agent_in_registry()

Returns compact JSON on stdout with three fields:
- `pane_capture_lines`: per-agent > global > hardcoded default 100
- `context_pressure_threshold`: per-agent > global > hardcoded default 50
- `hook_mode`: per-agent > global > hardcoded default "async"

Implementation:
1. Read global settings: `jq -r '.hook_settings // {}' "$registry_path" 2>/dev/null || printf '{}'`
2. Pipe agent_data_json through jq with `--argjson global "$global_settings"` and use jq `//` operator for three-tier fallback
3. On any jq failure, fall through to `printf '{"pane_capture_lines":100,"context_pressure_threshold":50,"hook_mode":"async"}'`
4. Use `printf '%s'` for piping (not echo)
5. Never exit non-zero. Never crash the calling hook.

Follow the exact implementation from research "Pattern 2: extract_hook_settings()".

**Function 2: detect_session_state()** (REFAC-05)

Unifies the two divergent state detection implementations across hook scripts. Uses the stop/notification hook pattern as the canonical form.

Arguments:
- `$1` - pane_content: string of current tmux pane capture

Returns one state name string on stdout. Detection priority order:
1. `menu` - matches `Enter to select|numbered.*option` (case-insensitive extended regex)
2. `permission_prompt` - matches `permission|allow|dangerous`
3. `idle` - matches `What can I help|waiting for`
4. `error` - matches `error|failed|exception` but excludes `error handling`
5. `working` - default fallback (always returned if no pattern matches)

Implementation:
1. Use `printf '%s\n' "$pane_content" | grep -Eiq 'pattern'` for each check (not echo)
2. The error check uses a two-stage grep: first `grep -Ei` to match, then pipe through `grep -v 'error handling'`
3. The else clause with `printf 'working'` must always be present
4. Never exit non-zero. Empty pane content returns "working".

Follow the exact implementation from research "Pattern 3: detect_session_state()".

**Important:** Include full function header comments matching the existing style in hook-utils.sh (see the `# ====` separator pattern, Arguments section, Returns section). Add a note in detect_session_state() header about pre-compact-hook.sh using different patterns (documented in research).

Update the file header comment to reflect the new function count: change "Sourced by all 6 hook scripts" to "Sourced by all hook scripts" (the count will change in Phase 13).
  </action>
  <verify>
Run these verification checks:

```bash
# 1. Both functions exist in hook-utils.sh
grep -q 'extract_hook_settings()' lib/hook-utils.sh && echo "PASS: extract_hook_settings exists" || echo "FAIL"
grep -q 'detect_session_state()' lib/hook-utils.sh && echo "PASS: detect_session_state exists" || echo "FAIL"

# 2. extract_hook_settings uses printf not echo for piping
grep -A20 'extract_hook_settings()' lib/hook-utils.sh | grep -q "printf '%s'" && echo "PASS: uses printf" || echo "FAIL"

# 3. detect_session_state uses grep -Eiq (case-insensitive extended)
grep -A20 'detect_session_state()' lib/hook-utils.sh | grep -q 'grep -Eiq' && echo "PASS: case-insensitive regex" || echo "FAIL"

# 4. detect_session_state has working fallback
grep -A30 'detect_session_state()' lib/hook-utils.sh | grep -q "printf 'working'" && echo "PASS: working fallback" || echo "FAIL"

# 5. Existing functions are unchanged (check first function signature)
grep -q 'lookup_agent_in_registry()' lib/hook-utils.sh && echo "PASS: existing functions intact" || echo "FAIL"

# 6. No side effects on source (no executable code outside functions)
bash -c 'source lib/hook-utils.sh && echo "PASS: no side effects"' || echo "FAIL: side effects"
```
  </verify>
  <done>lib/hook-utils.sh contains extract_hook_settings() with three-tier jq fallback returning compact JSON and detect_session_state() with case-insensitive extended regex returning consistent state names. Existing functions are unchanged. No side effects on source.</done>
</task>

<task type="auto">
  <name>Task 3: Create and run integration verification test</name>
  <files>lib/hook-preamble.sh, lib/hook-utils.sh</files>
  <action>
Create a temporary test script and run it to verify all five Phase 12 success criteria. The test script simulates a hook sourcing the preamble and calling the new functions.

**Create test script** at `scripts/test-phase12-integration.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PASS=0
FAIL=0

# --- Test 1: Source preamble and check HOOK_SCRIPT_NAME ---
source "${SCRIPT_DIR}/../lib/hook-preamble.sh"
if [[ "$HOOK_SCRIPT_NAME" == "test-phase12-integration.sh" ]]; then
  printf 'PASS: HOOK_SCRIPT_NAME=%s\n' "$HOOK_SCRIPT_NAME"
  ((PASS++))
else
  printf 'FAIL: HOOK_SCRIPT_NAME=%s (expected test-phase12-integration.sh)\n' "$HOOK_SCRIPT_NAME"
  ((FAIL++))
fi

# --- Test 2: Source guard prevents double-sourcing ---
_BEFORE_GUARD="$HOOK_SCRIPT_NAME"
source "${SCRIPT_DIR}/../lib/hook-preamble.sh"
if [[ "$HOOK_SCRIPT_NAME" == "$_BEFORE_GUARD" ]]; then
  printf 'PASS: source guard (double-source harmless)\n'
  ((PASS++))
else
  printf 'FAIL: source guard broken\n'
  ((FAIL++))
fi

# --- Test 3: hook-utils.sh functions are callable ---
if declare -f lookup_agent_in_registry >/dev/null 2>&1 \
   && declare -f extract_hook_settings >/dev/null 2>&1 \
   && declare -f detect_session_state >/dev/null 2>&1; then
  printf 'PASS: all hook-utils.sh functions callable\n'
  ((PASS++))
else
  printf 'FAIL: some hook-utils.sh functions not callable\n'
  ((FAIL++))
fi

# --- Test 4: extract_hook_settings three-tier fallback ---
TEST_REGISTRY=$(mktemp)
printf '{"hook_settings":{"pane_capture_lines":50},"agents":[]}' > "$TEST_REGISTRY"
TEST_AGENT='{"agent_id":"test","hook_settings":{"hook_mode":"bidirectional"}}'
SETTINGS=$(extract_hook_settings "$TEST_REGISTRY" "$TEST_AGENT")
PCL=$(printf '%s' "$SETTINGS" | jq -r '.pane_capture_lines')
CPT=$(printf '%s' "$SETTINGS" | jq -r '.context_pressure_threshold')
HM=$(printf '%s' "$SETTINGS" | jq -r '.hook_mode')
rm -f "$TEST_REGISTRY"

if [[ "$PCL" == "50" && "$CPT" == "50" && "$HM" == "bidirectional" ]]; then
  printf 'PASS: extract_hook_settings (pcl=%s cpt=%s hm=%s)\n' "$PCL" "$CPT" "$HM"
  ((PASS++))
else
  printf 'FAIL: extract_hook_settings (pcl=%s cpt=%s hm=%s)\n' "$PCL" "$CPT" "$HM"
  ((FAIL++))
fi

# --- Test 5: detect_session_state returns correct states ---
STATE_PASS=0
STATE_FAIL=0

check_state() {
  local input="$1" expected="$2"
  local actual
  actual=$(detect_session_state "$input")
  if [[ "$actual" == "$expected" ]]; then
    ((STATE_PASS++))
  else
    printf 'FAIL: detect_session_state("%s") = "%s" (expected "%s")\n' "$input" "$actual" "$expected"
    ((STATE_FAIL++))
  fi
}

check_state "Use arrow keys or Enter to select option" "menu"
check_state "Claude needs permission to run this command" "permission_prompt"
check_state "What can I help you with today?" "idle"
check_state "Error: command not found" "error"
check_state "Analyzing your codebase..." "working"
check_state "" "working"
# Case-insensitive test
check_state "ENTER TO SELECT an option" "menu"
check_state "Permission required" "permission_prompt"

if [[ "$STATE_FAIL" -eq 0 ]]; then
  printf 'PASS: detect_session_state (%d cases)\n' "$STATE_PASS"
  ((PASS++))
else
  printf 'FAIL: detect_session_state (%d passed, %d failed)\n' "$STATE_PASS" "$STATE_FAIL"
  ((FAIL++))
fi

# --- Summary ---
printf '\n=== Phase 12 Integration Test ===\n'
printf 'PASSED: %d  FAILED: %d\n' "$PASS" "$FAIL"
[[ "$FAIL" -eq 0 ]] && exit 0 || exit 1
```

Make it executable: `chmod +x scripts/test-phase12-integration.sh`

Run the test: `bash scripts/test-phase12-integration.sh`

All 5 tests must PASS. If any FAIL, fix the underlying issue in lib/hook-preamble.sh or lib/hook-utils.sh and re-run.

After all tests pass, **delete the test script** (`rm scripts/test-phase12-integration.sh`). It is a one-time verification artifact, not a permanent test suite. The functions are validated; Phase 13 will use them in production hooks.
  </action>
  <verify>
```bash
# Run the test - all must pass
bash scripts/test-phase12-integration.sh

# Also verify direct-exec guard separately (test script sources preamble, so we test direct exec here)
bash lib/hook-preamble.sh 2>&1; echo "exit_code=$?"
# Expected: error message on stderr, exit_code=1

# Clean up test script
rm -f scripts/test-phase12-integration.sh
```
  </verify>
  <done>All 5 integration tests pass: HOOK_SCRIPT_NAME shows test caller name, source guard prevents double-sourcing, all hook-utils.sh functions are callable via preamble, extract_hook_settings() returns correct three-tier fallback values, detect_session_state() returns correct state names for all test cases including case-insensitive and empty input. Test script deleted after verification.</done>
</task>

</tasks>

<verification>
After all tasks complete, verify the five Phase 12 success criteria from ROADMAP.md:

1. **BASH_SOURCE[1] correctness**: `HOOK_SCRIPT_NAME` set to caller's name, confirmed by integration test
2. **Source guard + direct-exec guard**: Double-source harmless, `bash lib/hook-preamble.sh` rejected
3. **extract_hook_settings() three-tier fallback**: Per-agent > global > hardcoded defaults, confirmed with test registry
4. **detect_session_state() consistent state names**: menu, permission_prompt, idle, error, working — case-insensitive
5. **Preamble sources hook-utils.sh**: All functions callable after single preamble source
</verification>

<success_criteria>
- lib/hook-preamble.sh exists and is executable
- lib/hook-utils.sh contains 8 functions (6 original + 2 new)
- No existing hook scripts were modified
- All integration tests pass
- Direct execution of preamble is rejected with clear error
</success_criteria>

<output>
After completion, create `.planning/phases/12-shared-library-foundation/12-01-SUMMARY.md`
</output>
