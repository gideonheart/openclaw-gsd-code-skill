---
phase: 13-coordinated-hook-migration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/stop-hook.sh
  - scripts/pre-tool-use-hook.sh
  - scripts/post-tool-use-hook.sh
autonomous: true
requirements:
  - REFAC-03
  - QUAL-01

must_haves:
  truths:
    - "stop-hook.sh sources hook-preamble.sh and does not source hook-utils.sh directly"
    - "pre-tool-use-hook.sh sources hook-preamble.sh and does not source hook-utils.sh directly"
    - "post-tool-use-hook.sh sources hook-preamble.sh and does not source hook-utils.sh directly"
    - "stop-hook.sh uses extract_hook_settings() instead of inline settings extraction"
    - "stop-hook.sh uses detect_session_state() instead of inline state detection"
    - "No hook in this plan has echo-to-jq piping patterns"
  artifacts:
    - path: "scripts/stop-hook.sh"
      provides: "Migrated stop hook with shared settings and state detection"
      contains: "source.*hook-preamble.sh"
    - path: "scripts/pre-tool-use-hook.sh"
      provides: "Migrated pre-tool-use hook"
      contains: "source.*hook-preamble.sh"
    - path: "scripts/post-tool-use-hook.sh"
      provides: "Migrated post-tool-use hook"
      contains: "source.*hook-preamble.sh"
  key_links:
    - from: "scripts/stop-hook.sh"
      to: "lib/hook-preamble.sh"
      via: "source statement"
      pattern: "source.*hook-preamble\\.sh"
    - from: "scripts/pre-tool-use-hook.sh"
      to: "lib/hook-preamble.sh"
      via: "source statement"
      pattern: "source.*hook-preamble\\.sh"
    - from: "scripts/post-tool-use-hook.sh"
      to: "lib/hook-preamble.sh"
      via: "source statement"
      pattern: "source.*hook-preamble\\.sh"
---

<objective>
Migrate stop-hook.sh, pre-tool-use-hook.sh, and post-tool-use-hook.sh to use the shared library chain. Stop-hook is the most complex (has transcript extraction, pane diff fallback, context pressure, bidirectional mode) and gets preamble, settings, state detection, and echo-to-printf. Pre-tool-use and post-tool-use already use printf for jq piping and only need preamble migration.

Purpose: Complete the preamble migration across all remaining hooks, making stop-hook.sh consistent with shared library functions.
Output: Three migrated hook scripts sourcing hook-preamble.sh with zero direct hook-utils.sh references.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-coordinated-hook-migration/13-RESEARCH.md
@lib/hook-preamble.sh
@lib/hook-utils.sh
@scripts/stop-hook.sh
@scripts/pre-tool-use-hook.sh
@scripts/post-tool-use-hook.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate stop-hook.sh</name>
  <files>scripts/stop-hook.sh</files>
  <action>
Replace the entire preamble block (lines 1-27: shebang, set -euo, SKILL_LOG_DIR, mkdir, GSD_HOOK_LOG, HOOK_SCRIPT_NAME, debug_log function, FIRED log, SCRIPT_DIR, LIB_PATH, source hook-utils.sh, debug_log "sourced") with exactly:

```bash
#!/usr/bin/env bash
set -euo pipefail
source "$(cd "$(dirname "${BASH_SOURCE[0]}")/../lib" && pwd)/hook-preamble.sh"
```

Then apply these changes to the remaining hook body:

1. **Remove REGISTRY_PATH line** (currently `REGISTRY_PATH="${SCRIPT_DIR}/../config/recovery-registry.json"`) — already set by preamble.

2. **Replace inline settings block** (lines 99-111: GLOBAL_SETTINGS + PANE_CAPTURE_LINES + CONTEXT_PRESSURE_THRESHOLD + HOOK_MODE) with:
```bash
HOOK_SETTINGS_JSON=$(extract_hook_settings "$REGISTRY_PATH" "$AGENT_DATA")
PANE_CAPTURE_LINES=$(printf '%s' "$HOOK_SETTINGS_JSON" | jq -r '.pane_capture_lines')
CONTEXT_PRESSURE_THRESHOLD=$(printf '%s' "$HOOK_SETTINGS_JSON" | jq -r '.context_pressure_threshold')
HOOK_MODE=$(printf '%s' "$HOOK_SETTINGS_JSON" | jq -r '.hook_mode')
```

3. **Replace inline state detection** (lines 132-142: STATE="working" + if/elif/fi block using echo + grep) with:
```bash
STATE=$(detect_session_state "$PANE_CONTENT")
```

4. **Replace all echo-to-jq patterns** with printf equivalents:
- `echo "$STDIN_JSON" | jq -r '.hook_event_name` -> `printf '%s' "$STDIN_JSON" | jq -r '.hook_event_name`
- `echo "$STDIN_JSON" | jq -r '.stop_hook_active` -> `printf '%s' "$STDIN_JSON" | jq -r '.stop_hook_active`
- `echo "$AGENT_DATA" | jq -r '.agent_id'` -> `printf '%s' "$AGENT_DATA" | jq -r '.agent_id'`
- `echo "$AGENT_DATA" | jq -r '.openclaw_session_id'` -> `printf '%s' "$AGENT_DATA" | jq -r '.openclaw_session_id'`
- `echo "$PANE_CONTENT" | tail -5` -> `printf '%s\n' "$PANE_CONTENT" | tail -5`
- `echo "$RESPONSE" | jq -r '.decision'` -> `printf '%s' "$RESPONSE" | jq -r '.decision'`
- `echo "$RESPONSE" | jq -r '.reason'` -> `printf '%s' "$RESPONSE" | jq -r '.reason'`

Note: Line 121 (`printf '%s' "$STDIN_JSON" | jq -r '.transcript_path'`) already uses printf — leave unchanged.

IMPORTANT: stop-hook.sh already uses [CONTENT] (not [PANE CONTENT]) — do NOT change the wake message label.

Preserve all other logic unchanged: stdin consumption, stop_hook_active guard, TMUX guard, session name extraction, log redirect, registry lookup, pane capture, transcript extraction (extract_last_assistant_response), pane diff fallback, context pressure extraction, content determination logic, wake message v2 format, hybrid delivery mode, bidirectional response parsing, JSONL logging.
  </action>
  <verify>
Run these checks:
```bash
# Sources preamble
grep -c 'source.*hook-preamble.sh' scripts/stop-hook.sh  # expect 1
# Does NOT source hook-utils.sh directly
grep -c 'source.*hook-utils.sh' scripts/stop-hook.sh  # expect 0
# Still uses [CONTENT] (was already correct)
grep -c '\[CONTENT\]' scripts/stop-hook.sh  # expect 1
# Uses extract_hook_settings
grep -c 'extract_hook_settings' scripts/stop-hook.sh  # expect 1
# Uses detect_session_state
grep -c 'detect_session_state' scripts/stop-hook.sh  # expect 1
# No echo-to-jq patterns
grep -c 'echo.*\$.*| jq' scripts/stop-hook.sh  # expect 0
# Script is syntactically valid
bash -n scripts/stop-hook.sh
```
  </verify>
  <done>stop-hook.sh sources hook-preamble.sh, uses extract_hook_settings(), uses detect_session_state(), has zero echo-to-jq patterns, and passes bash -n syntax check.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate pre-tool-use-hook.sh and post-tool-use-hook.sh</name>
  <files>scripts/pre-tool-use-hook.sh, scripts/post-tool-use-hook.sh</files>
  <action>
Both hooks already use `printf '%s'` for jq piping (no echo-to-jq patterns). They only need preamble migration.

**For each hook**, replace the entire preamble block (lines 1-27) with:

```bash
#!/usr/bin/env bash
set -euo pipefail
source "$(cd "$(dirname "${BASH_SOURCE[0]}")/../lib" && pwd)/hook-preamble.sh"
```

Then:
1. **Remove REGISTRY_PATH line** — already set by preamble.

Preserve all other logic unchanged. These hooks do not use settings extraction, state detection, or [PANE CONTENT] labels — their preamble migration is minimal.

Note: pre-tool-use-hook.sh does NOT use extract_hook_settings() (per user decision: hooks that don't use settings don't get the call). Post-tool-use-hook.sh similarly does not use settings.
  </action>
  <verify>
Run these checks:
```bash
for hook in pre-tool-use-hook.sh post-tool-use-hook.sh; do
  echo "=== $hook ==="
  # Sources preamble
  grep -c 'source.*hook-preamble.sh' scripts/$hook  # expect 1
  # Does NOT source hook-utils.sh directly
  grep -c 'source.*hook-utils.sh' scripts/$hook  # expect 0
  # No echo-to-jq patterns (should already be 0)
  grep -c 'echo.*\$.*| jq' scripts/$hook  # expect 0
  # Script is syntactically valid
  bash -n scripts/$hook && echo "syntax: OK" || echo "syntax: FAIL"
done
```
  </verify>
  <done>pre-tool-use-hook.sh and post-tool-use-hook.sh both source hook-preamble.sh, neither sources hook-utils.sh directly, and both pass bash -n syntax check.</done>
</task>

<task type="auto">
  <name>Task 3: Cross-hook verification sweep</name>
  <files></files>
  <action>
Run the comprehensive verification sweep across ALL 7 hook scripts to confirm all Phase 13 success criteria are met by this plan's hooks (stop, pre-tool-use, post-tool-use) combined with plans 01 and 02.

Execute these verification commands:

```bash
# SC-1: Every hook sources hook-preamble.sh
echo "=== REFAC-03: Preamble sourcing ==="
for hook in stop-hook.sh notification-idle-hook.sh notification-permission-hook.sh pre-compact-hook.sh session-end-hook.sh pre-tool-use-hook.sh post-tool-use-hook.sh; do
  count=$(grep -c 'source.*hook-preamble.sh' scripts/$hook 2>/dev/null || echo 0)
  echo "$hook: preamble=$count"
done

# SC-1b: No hook sources hook-utils.sh directly
echo "=== REFAC-03: No direct hook-utils.sh ==="
grep -l 'source.*hook-utils.sh' scripts/*-hook.sh 2>/dev/null && echo "FAIL: direct sources found" || echo "PASS: no direct sources"

# SC-2: No [PANE CONTENT] in any hook
echo "=== MIGR-01/02/03: No [PANE CONTENT] ==="
grep -r '\[PANE CONTENT\]' scripts/*-hook.sh 2>/dev/null && echo "FAIL" || echo "PASS"

# SC-3: No echo-to-jq in any hook
echo "=== QUAL-01: No echo-to-jq ==="
grep -n 'echo.*\$.*| jq' scripts/*-hook.sh 2>/dev/null && echo "FAIL" || echo "PASS"

# All scripts pass syntax check
echo "=== Syntax validation ==="
for hook in stop-hook.sh notification-idle-hook.sh notification-permission-hook.sh pre-compact-hook.sh session-end-hook.sh pre-tool-use-hook.sh post-tool-use-hook.sh; do
  bash -n scripts/$hook 2>&1 && echo "$hook: OK" || echo "$hook: FAIL"
done
```

If any check fails, report the failure — do NOT fix files owned by other plans. Only this plan's files (stop-hook.sh, pre-tool-use-hook.sh, post-tool-use-hook.sh) can be modified.
  </action>
  <verify>All verification commands above return PASS for all 7 hooks.</verify>
  <done>All 7 hooks pass the cross-hook verification sweep: preamble sourcing confirmed, no direct hook-utils.sh sources, no [PANE CONTENT] labels, no echo-to-jq patterns, all syntax valid.</done>
</task>

</tasks>

<verification>
Full Phase 13 verification (all 7 hooks):
```bash
echo "=== Phase 13 Final Verification ==="

# REFAC-03: All 7 hooks source hook-preamble.sh
PREAMBLE_COUNT=$(grep -l 'source.*hook-preamble.sh' scripts/*-hook.sh | wc -l)
echo "Hooks sourcing preamble: $PREAMBLE_COUNT/7"

# REFAC-03: Zero direct hook-utils.sh sources
DIRECT_COUNT=$(grep -l 'source.*hook-utils.sh' scripts/*-hook.sh 2>/dev/null | wc -l)
echo "Hooks with direct hook-utils.sh: $DIRECT_COUNT (expect 0)"

# MIGR-01/02/03: Zero [PANE CONTENT]
PANE_CONTENT_COUNT=$(grep -r '\[PANE CONTENT\]' scripts/*-hook.sh 2>/dev/null | wc -l)
echo "[PANE CONTENT] occurrences: $PANE_CONTENT_COUNT (expect 0)"

# QUAL-01: Zero echo-to-jq
ECHO_JQ_COUNT=$(grep -c 'echo.*\$.*| jq' scripts/*-hook.sh 2>/dev/null | awk -F: '{s+=$2}END{print s}')
echo "echo-to-jq patterns: $ECHO_JQ_COUNT (expect 0)"

# FIX-03: session-end jq guards
UNGUARDED=$(grep 'jq' scripts/session-end-hook.sh | grep -v '2>/dev/null' | grep -v '^#' | wc -l)
echo "session-end unguarded jq: $UNGUARDED (expect 0)"
```
</verification>

<success_criteria>
- All 3 hooks (stop, pre-tool-use, post-tool-use) source hook-preamble.sh
- None source hook-utils.sh directly
- stop-hook.sh uses extract_hook_settings() and detect_session_state()
- Zero echo-to-jq patterns across all 3 hooks
- All 3 pass bash -n syntax validation
- Cross-hook sweep confirms all 7 hooks meet Phase 13 success criteria
</success_criteria>

<output>
After completion, create `.planning/phases/13-coordinated-hook-migration/13-03-SUMMARY.md`
</output>
