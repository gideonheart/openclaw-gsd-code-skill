---
phase: 09-hook-script-migration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/stop-hook.sh
autonomous: true
requirements: [HOOK-12]

must_haves:
  truths:
    - "stop-hook.sh writes one JSONL record per invocation containing trigger, state, content_source, full wake_message body, OpenClaw response, outcome, and duration_ms"
    - "stop-hook.sh JSONL record content_source is dynamically set: transcript, pane_diff, or raw_pane_tail depending on extraction result"
    - "stop-hook.sh bidirectional branch writes JSONL via write_hook_event_record() with outcome=sync_delivered and includes the OpenClaw response"
    - "stop-hook.sh async branch writes JSONL via deliver_async_with_logging()"
    - "stop-hook.sh sources lib/hook-utils.sh before any guard exit"
    - "All existing debug_log calls remain unchanged"
    - "Guard exits (stop_hook_active, no TMUX, no registry) do NOT emit JSONL records"
  artifacts:
    - path: "scripts/stop-hook.sh"
      provides: "JSONL-emitting stop hook with bidirectional support and dynamic content_source"
      contains: "deliver_async_with_logging"
  key_links:
    - from: "scripts/stop-hook.sh"
      to: "lib/hook-utils.sh"
      via: "source at top of script before guards"
      pattern: "source.*hook-utils\\.sh"
    - from: "scripts/stop-hook.sh"
      to: "logs/{SESSION_NAME}.jsonl"
      via: "deliver_async_with_logging (async) and write_hook_event_record (bidirectional)"
      pattern: "deliver_async_with_logging|write_hook_event_record"
---

<objective>
Migrate stop-hook.sh — the most complex hook script — to emit structured JSONL records. stop-hook.sh has a bidirectional branch with synchronous OpenClaw call, a dynamic CONTENT_SOURCE that varies by extraction result (transcript/pane_diff/raw_pane_tail), and the stop_hook_active infinite-loop guard.

Purpose: Complete JSONL migration for the highest-complexity hook. The JSONL record must contain the full wake message body and OpenClaw response (HOOK-12 requirement), and content_source must accurately reflect which extraction method produced the content.

Output: Modified stop-hook.sh with JSONL logging in both delivery paths, dynamic CONTENT_SOURCE, and all existing behavior preserved.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-jsonl-logging-foundation/08-02-SUMMARY.md
@lib/hook-utils.sh
@scripts/stop-hook.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate stop-hook.sh to JSONL with dynamic content_source and bidirectional support</name>
  <files>scripts/stop-hook.sh</files>
  <action>
Apply the 5-change migration pattern with stop-hook-specific handling:

**Change 1: Move lib source to top.** After debug_log definition and "FIRED" log line, add SCRIPT_DIR and source block. Note: stop-hook.sh has a `debug_log "sourced lib/hook-utils.sh"` inside the old mid-script block — move that debug_log line to the new top-level source block (inside the if-true branch after `source "$LIB_PATH"`).

**Change 2: Add HOOK_ENTRY_MS.** Immediately after `STDIN_JSON=$(cat)`, add `HOOK_ENTRY_MS=$(date +%s%3N)`. Place it BEFORE the stop_hook_active guard check (HOOK_ENTRY_MS should capture timing even though stop_hook_active exits early — but this is fine since guard exits do not emit JSONL).

**Change 3: Add JSONL_FILE in Phase 2 redirect.** After `GSD_HOOK_LOG="${SKILL_LOG_DIR}/${SESSION_NAME}.log"`, add `JSONL_FILE="${SKILL_LOG_DIR}/${SESSION_NAME}.jsonl"`.

**Change 4: Delete mid-script LIB_PATH + source block.** Remove the existing source block in section 5 (after REGISTRY_PATH check). Keep REGISTRY_PATH check and lookup. Remove the now-redundant SCRIPT_DIR assignment in section 5 (already set at top).

**Change 5a: Set CONTENT_SOURCE in section 9b (content determination block).**

The content determination block in section 9b already has three branches. Add CONTENT_SOURCE assignment in each:
```bash
if [ -n "$EXTRACTED_RESPONSE" ]; then
  CONTENT_SECTION="$EXTRACTED_RESPONSE"
  CONTENT_SOURCE="transcript"
  debug_log "content source: transcript"
else
  PANE_FOR_DIFF=$(printf '%s\n' "$PANE_CONTENT" | tail -40)
  if type extract_pane_diff &>/dev/null; then
    CONTENT_SECTION=$(extract_pane_diff "$SESSION_NAME" "$PANE_FOR_DIFF")
    CONTENT_SOURCE="pane_diff"
    debug_log "content source: pane_diff (delta_length=${#CONTENT_SECTION})"
  else
    CONTENT_SECTION=$(printf '%s\n' "$PANE_CONTENT" | tail -40)
    CONTENT_SOURCE="raw_pane_tail"
    debug_log "content source: raw_pane_tail (lib not available)"
  fi
fi
```

**Change 5b: Set TRIGGER before delivery.** Just before the delivery section (section 11):
```bash
TRIGGER="response_complete"
```

**Change 5c: Bidirectional branch JSONL.** After the synchronous openclaw call and `debug_log "RESPONSE: ${RESPONSE:0:200}"`, add write_hook_event_record:
```bash
write_hook_event_record \
  "$JSONL_FILE" "$HOOK_ENTRY_MS" "$HOOK_SCRIPT_NAME" "$SESSION_NAME" \
  "$AGENT_ID" "$OPENCLAW_SESSION_ID" "$TRIGGER" "$STATE" \
  "$CONTENT_SOURCE" "$WAKE_MESSAGE" "$RESPONSE" "sync_delivered"
```
Place this BEFORE the decision parsing block (before `if [ -n "$RESPONSE" ]; then` DECISION/REASON parsing). The JSONL record captures the raw response; the decision parsing is separate logic.

**Change 5d: Async branch replacement.** Replace bare openclaw call:
```bash
deliver_async_with_logging \
  "$OPENCLAW_SESSION_ID" "$WAKE_MESSAGE" "$JSONL_FILE" "$HOOK_ENTRY_MS" \
  "$HOOK_SCRIPT_NAME" "$SESSION_NAME" "$AGENT_ID" \
  "$TRIGGER" "$STATE" "$CONTENT_SOURCE"
debug_log "DELIVERED (async with JSONL logging)"
```

Keep ALL existing debug_log calls. Do NOT modify content extraction logic (section 7b, 9b). Do NOT modify decision parsing (DECISION/REASON/block logic). Do NOT modify state detection or context pressure extraction.
  </action>
  <verify>
Run: `bash -n scripts/stop-hook.sh` (syntax check passes).
Run: `grep -c 'deliver_async_with_logging' scripts/stop-hook.sh` returns 1.
Run: `grep -c 'write_hook_event_record' scripts/stop-hook.sh` returns 1.
Run: `grep -c 'HOOK_ENTRY_MS' scripts/stop-hook.sh` returns 1.
Run: `grep -c 'JSONL_FILE' scripts/stop-hook.sh` returns 3 (assignment + async usage + sync usage).
Run: `grep -c 'CONTENT_SOURCE=' scripts/stop-hook.sh` returns 3 (transcript, pane_diff, raw_pane_tail).
Run: `grep 'TRIGGER=' scripts/stop-hook.sh` contains "response_complete".
Verify lib sourced before first guard exit (before stop_hook_active check).
Verify only one `source "$LIB_PATH"` in the file.
Verify bidirectional branch has write_hook_event_record with outcome "sync_delivered".
Verify no bare `openclaw agent` call remains in async branch.
Verify decision parsing block (DECISION/REASON) is untouched.
  </verify>
  <done>stop-hook.sh emits one JSONL record per invocation with dynamic content_source (transcript/pane_diff/raw_pane_tail), trigger=response_complete, full wake_message body, OpenClaw response (bidirectional), and duration_ms. Both delivery paths covered. All debug_log calls and existing logic preserved.</done>
</task>

</tasks>

<verification>
1. `bash -n scripts/stop-hook.sh` — syntax check passes
2. Exactly ONE `source "$LIB_PATH"` call in the file
3. Source call appears BEFORE stop_hook_active guard exit (the first exit 0)
4. HOOK_ENTRY_MS set immediately after STDIN_JSON=$(cat)
5. JSONL_FILE assigned in Phase 2 redirect block
6. CONTENT_SOURCE is set to one of three values depending on extraction result
7. TRIGGER="response_complete" is set before delivery
8. Bidirectional branch has write_hook_event_record with all 12 parameters
9. Async branch has deliver_async_with_logging with all 10 parameters
10. Decision parsing (DECISION/REASON/block) unchanged
11. All debug_log calls preserved
12. Guard exits do NOT call JSONL functions
</verification>

<success_criteria>
stop-hook.sh writes one complete JSONL record per invocation containing trigger, state, content_source, full wake_message body, OpenClaw response, outcome, and duration_ms. Content source dynamically reflects extraction method used. Both async and bidirectional paths emit JSONL. All existing behavior preserved.
</success_criteria>

<output>
After completion, create `.planning/phases/09-hook-script-migration/09-03-SUMMARY.md`
</output>
