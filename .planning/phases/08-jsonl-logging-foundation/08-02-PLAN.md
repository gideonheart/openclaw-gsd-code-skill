---
phase: 08-jsonl-logging-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - lib/hook-utils.sh
  - tests/test-deliver-async-with-logging.sh
autonomous: true
requirements:
  - JSONL-05

must_haves:
  truths:
    - "deliver_async_with_logging() spawns a background subshell that calls openclaw and writes a JSONL record after the response arrives"
    - "Background subshell uses explicit </dev/null to prevent stdin inheritance hangs"
    - "The calling hook exits immediately after deliver_async_with_logging() returns — it does NOT wait for the background subshell"
    - "openclaw failure still produces a JSONL record with outcome field reflecting the error"
    - "deliver_async_with_logging() is testable in isolation by mocking openclaw with a local function"
  artifacts:
    - path: "lib/hook-utils.sh"
      provides: "deliver_async_with_logging function alongside write_hook_event_record"
      contains: "deliver_async_with_logging"
    - path: "tests/test-deliver-async-with-logging.sh"
      provides: "Integration test for deliver_async_with_logging with mocked openclaw"
      contains: "PASS"
  key_links:
    - from: "lib/hook-utils.sh (deliver_async_with_logging)"
      to: "lib/hook-utils.sh (write_hook_event_record)"
      via: "Background subshell calls write_hook_event_record after openclaw response"
      pattern: "write_hook_event_record"
    - from: "lib/hook-utils.sh (deliver_async_with_logging)"
      to: "openclaw"
      via: "openclaw agent --session-id in background subshell"
      pattern: "openclaw agent.*--session-id"
---

<objective>
Create the `deliver_async_with_logging()` function in lib/hook-utils.sh and an integration test that verifies the full async delivery + JSONL logging pipeline using a mocked openclaw command.

Purpose: This wrapper replaces bare `openclaw ... &` calls in all async hook delivery paths. It captures the OpenClaw response in a background subshell and writes a complete JSONL record via write_hook_event_record(). Phase 9 will swap the existing bare openclaw calls to use this function.

Output: Extended lib/hook-utils.sh with deliver_async_with_logging(), plus tests/test-deliver-async-with-logging.sh proving the async pipeline works end-to-end.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-jsonl-logging-foundation/08-RESEARCH.md
@.planning/phases/08-jsonl-logging-foundation/08-01-SUMMARY.md
@lib/hook-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deliver_async_with_logging() function to lib/hook-utils.sh</name>
  <files>lib/hook-utils.sh</files>
  <action>
Append the `deliver_async_with_logging()` function to the end of lib/hook-utils.sh (after the `write_hook_event_record` function added by Plan 08-01).

Function signature with 10 explicit positional parameters:
1. openclaw_session_id — OpenClaw session ID for the agent
2. wake_message — full wake message body to deliver
3. jsonl_file — path to the per-session .jsonl log file
4. hook_entry_ms — millisecond timestamp from hook start
5. hook_script — basename of the calling hook script
6. session_name — tmux session name
7. agent_id — agent identifier
8. trigger — event trigger type
9. state — detected state
10. content_source — how content was obtained

Implementation:
- Spawn a background subshell `(...) </dev/null &`
- Inside the subshell:
  - Capture response: `response=$(openclaw agent --session-id "$openclaw_session_id" --message "$wake_message" 2>&1) || true`
  - Determine outcome: `outcome="delivered"` by default; `outcome="no_response"` if response is empty
  - Call `write_hook_event_record` with all 12 parameters (the 10 passed in plus response and outcome determined in the subshell)
- `</dev/null` MUST be on the subshell to prevent stdin inheritance from Claude Code's pipe
- `&` MUST background the subshell so the hook exits immediately
- `|| true` on the openclaw call so failures do not kill the subshell
- The function itself returns immediately after spawning the subshell (no `wait`)

Add a comment block above the function following the existing documentation style.

IMPORTANT: Do NOT modify any existing function in lib/hook-utils.sh. Only append the new function at the end of the file.
  </action>
  <verify>
Run: `bash -n lib/hook-utils.sh` — must exit 0 (no syntax errors).
Run: `source lib/hook-utils.sh && type deliver_async_with_logging` — must show the function is defined.
Run: `source lib/hook-utils.sh && type write_hook_event_record` — must still be defined (Plan 01 function unchanged).
Run: `grep -c 'deliver_async_with_logging' lib/hook-utils.sh` — must be >= 2.
  </verify>
  <done>deliver_async_with_logging() function exists in lib/hook-utils.sh with 10 parameters, background subshell with </dev/null, openclaw response capture, outcome determination, and write_hook_event_record call inside the subshell.</done>
</task>

<task type="auto">
  <name>Task 2: Create integration test for deliver_async_with_logging()</name>
  <files>tests/test-deliver-async-with-logging.sh</files>
  <action>
Create `tests/test-deliver-async-with-logging.sh` as an executable bash script (`chmod +x`). This test verifies deliver_async_with_logging() by mocking the `openclaw` command with a local function.

Test structure:
1. `#!/usr/bin/env bash` and `set -euo pipefail`
2. Resolve SKILL_DIR via `$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)`
3. Create temp test directory: `TEST_LOG_DIR=$(mktemp -d "/tmp/gsd-test-XXXXXX")`
4. Trap cleanup: `trap 'rm -rf "$TEST_LOG_DIR"' EXIT`
5. Source the library: `source "${SKILL_DIR}/lib/hook-utils.sh"`

**Mock openclaw command:**
Before running tests, define a function that overrides the `openclaw` command:
```bash
openclaw() {
  # Mock: return a simulated response based on arguments
  printf '{"status":"delivered","agent":"test"}'
}
```
This works because bash function lookup takes priority over PATH-based command lookup.

**Test A — Successful async delivery produces JSONL record:**
- Set JSONL_FILE="${TEST_LOG_DIR}/async-test.jsonl"
- Set HOOK_ENTRY_MS=$(date +%s%3N)
- Call deliver_async_with_logging with: openclaw_session_id="test-session-id", wake_message="test wake message", jsonl_file="$JSONL_FILE", hook_entry_ms="$HOOK_ENTRY_MS", hook_script="stop-hook.sh", session_name="test-session", agent_id="test-agent", trigger="response_complete", state="working", content_source="transcript"
- Wait briefly for background subshell: `sleep 1` (background needs time to complete)
- Assert: JSONL file exists and has exactly 1 line
- Assert: `jq -e '.outcome == "delivered"'` (openclaw mock returned non-empty response)
- Assert: `jq -e '.response | contains("delivered")'` (response captured from mock)
- Assert: `jq -e '.duration_ms | type == "number"'` (integer duration)
- Assert: `jq -e '.wake_message == "test wake message"'` (wake message passed through)

**Test B — Failed openclaw produces record with no_response outcome:**
- Redefine mock: `openclaw() { return 1; }` (simulates failure with no output)
- Set JSONL_FILE="${TEST_LOG_DIR}/async-fail-test.jsonl"
- Call deliver_async_with_logging with same parameters but different jsonl_file
- Wait: `sleep 1`
- Assert: JSONL file exists and has exactly 1 line
- Assert: `jq -e '.outcome == "no_response"'` (empty response detected)
- Assert: `jq -e '.response == ""'` (empty response captured)

**Test C — Wake message with special characters survives async pipeline:**
- Redefine mock: `openclaw() { printf 'OK'; }` (simple success)
- Set JSONL_FILE="${TEST_LOG_DIR}/async-special-test.jsonl"
- Set special_wake_message=$(printf 'line1\nline2 with "quotes"\nembedded: {"key":"val"}')
- Call deliver_async_with_logging with wake_message="$special_wake_message"
- Wait: `sleep 1`
- Assert: `jq -e '.wake_message | contains("quotes")'` (quotes survived)
- Assert: `jq -e '.'` (valid JSON)

Use the same assert_jq helper pattern as test-write-hook-event-record.sh. Print "PASS: {test_name}" for each passing assertion. Final line: "All tests passed".
  </action>
  <verify>
Run: `bash tests/test-deliver-async-with-logging.sh` — must print all PASS lines and end with "All tests passed".
Run: `bash -n tests/test-deliver-async-with-logging.sh` — must exit 0 (no syntax errors).
  </verify>
  <done>Integration test script exists at tests/test-deliver-async-with-logging.sh, is executable, mocks openclaw to test the full async pipeline in isolation, and all assertions pass — proving deliver_async_with_logging() correctly backgrounds delivery, captures responses, determines outcomes, and writes valid JSONL records via write_hook_event_record().</done>
</task>

</tasks>

<verification>
1. `bash -n lib/hook-utils.sh` — syntax valid
2. `source lib/hook-utils.sh && type deliver_async_with_logging && type write_hook_event_record` — both functions defined
3. `bash tests/test-deliver-async-with-logging.sh` — all tests pass
4. `bash tests/test-write-hook-event-record.sh` — Plan 01 tests still pass (no regression)
5. All original functions still defined: `source lib/hook-utils.sh && type lookup_agent_in_registry && type extract_last_assistant_response && type extract_pane_diff && type format_ask_user_questions`
</verification>

<success_criteria>
- deliver_async_with_logging() is appended to lib/hook-utils.sh without modifying existing functions
- Function spawns background subshell with explicit </dev/null and &
- Background subshell captures openclaw response, determines outcome, calls write_hook_event_record
- Integration test uses mocked openclaw to verify: successful delivery, failed delivery, special character handling
- Plan 01's write_hook_event_record tests still pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/08-jsonl-logging-foundation/08-02-SUMMARY.md`
</output>
