---
phase: 08-jsonl-logging-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/hook-utils.sh
  - tests/test-write-hook-event-record.sh
autonomous: true
requirements:
  - JSONL-01
  - JSONL-02
  - JSONL-03
  - JSONL-04
  - JSONL-05
  - OPS-01

must_haves:
  truths:
    - "write_hook_event_record() produces a single valid JSONL record containing all 12 lifecycle fields"
    - "String fields with newlines, quotes, ANSI codes, and embedded JSON are correctly escaped in the JSONL output"
    - "Concurrent appends to the same JSONL file produce valid, uncorrupted records"
    - "duration_ms is an integer (not string) in the JSONL record"
    - "JSONL file is written to logs/{SESSION_NAME}.jsonl path"
    - "jq construction failure does not crash the calling hook (silent fail)"
    - "flock timeout does not crash the calling hook (silent skip)"
  artifacts:
    - path: "lib/hook-utils.sh"
      provides: "write_hook_event_record function"
      contains: "write_hook_event_record"
    - path: "tests/test-write-hook-event-record.sh"
      provides: "Isolated unit test for write_hook_event_record"
      contains: "PASS"
  key_links:
    - from: "lib/hook-utils.sh"
      to: "jq"
      via: "jq -cn --arg for string fields, --argjson for duration_ms integer"
      pattern: "jq -cn.*--arg.*--argjson duration_ms"
    - from: "lib/hook-utils.sh"
      to: "flock"
      via: "flock -x -w 2 on ${jsonl_file}.lock for atomic JSONL append"
      pattern: "flock -x -w 2"
---

<objective>
Create the `write_hook_event_record()` function in lib/hook-utils.sh and a standalone unit test that verifies it works in isolation.

Purpose: This function is the single write point for ALL structured JSONL records across all 6 hook scripts. Correctness rules (jq --arg escaping, flock atomic append, --argjson for integers, silent failure) are established here before any hook uses them in Phase 9.

Output: Extended lib/hook-utils.sh with write_hook_event_record(), plus tests/test-write-hook-event-record.sh proving it works.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-jsonl-logging-foundation/08-RESEARCH.md
@lib/hook-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add write_hook_event_record() function to lib/hook-utils.sh</name>
  <files>lib/hook-utils.sh</files>
  <action>
Append the `write_hook_event_record()` function to the end of lib/hook-utils.sh (after the existing `format_ask_user_questions` function). The function takes 12 explicit positional parameters and writes a single JSONL record atomically.

Function signature with 12 positional parameters:
1. jsonl_file — path to the per-session .jsonl log file (logs/{SESSION_NAME}.jsonl)
2. hook_entry_ms — millisecond timestamp captured at hook start via `date +%s%3N`
3. hook_script — basename of the calling hook script (e.g., "stop-hook.sh")
4. session_name — tmux session name
5. agent_id — agent identifier from registry
6. openclaw_session_id — OpenClaw session ID from registry
7. trigger — event trigger type (e.g., "response_complete", "idle_prompt", "session_end")
8. state — detected state (e.g., "working", "menu", "idle")
9. content_source — how content was obtained ("transcript", "pane_diff", "raw_pane_tail", "pane", "questions", "none")
10. wake_message — full wake message body (may contain newlines, quotes, ANSI codes, embedded JSON)
11. response — OpenClaw response text (may be empty)
12. outcome — delivery result ("delivered", "no_response", "openclaw_error", "sync_delivered")

Implementation details:
- Compute `hook_exit_ms=$(date +%s%3N)` and `duration_ms=$((hook_exit_ms - hook_entry_ms))` inside the function
- Build the JSON record using `jq -cn` with `--arg` for all 11 string fields and `--argjson duration_ms "$duration_ms"` for the integer field
- Add `2>/dev/null` to the jq command and `|| return 0` — if jq fails, return silently (never crash the hook)
- Check `[ -z "$record" ] && return 0` after jq (empty record means jq failed)
- Append atomically using flock: `(flock -x -w 2 200 || return 0; printf '%s\n' "$record" >> "$jsonl_file") 200>"${jsonl_file}.lock" 2>/dev/null || true`
- The `|| true` on the entire flock block prevents set -e from triggering in the calling hook

The JSON record schema has these 13 fields:
- timestamp (ISO 8601 UTC, generated inside the function via `date -u +'%Y-%m-%dT%H:%M:%SZ'`)
- hook_script, session_name, agent_id, openclaw_session_id (identity)
- trigger, state, content_source (event classification)
- wake_message, response (content — potentially large strings)
- outcome (delivery result)
- duration_ms (integer — milliseconds from hook entry to record write)

Use the exact jq pattern from research section "Pattern 1: write_hook_event_record()".

Add a comment block above the function following the existing documentation style in hook-utils.sh (see lookup_agent_in_registry, extract_last_assistant_response as examples).
  </action>
  <verify>
Run: `bash -n lib/hook-utils.sh` — must exit 0 (no syntax errors).
Run: `source lib/hook-utils.sh && type write_hook_event_record` — must show the function is defined.
Run: `grep -c 'write_hook_event_record' lib/hook-utils.sh` — must be >= 2 (function definition + at least one reference in comments).
  </verify>
  <done>write_hook_event_record() function exists in lib/hook-utils.sh with all 12 parameters, jq --arg escaping for strings, --argjson for duration_ms integer, flock-based atomic append, and silent failure on jq error or flock timeout.</done>
</task>

<task type="auto">
  <name>Task 2: Create unit test for write_hook_event_record()</name>
  <files>tests/test-write-hook-event-record.sh</files>
  <action>
Create `tests/test-write-hook-event-record.sh` as an executable bash script (`chmod +x`). This test verifies write_hook_event_record() in complete isolation — no tmux, no openclaw, no Claude Code session.

Test structure:
1. `#!/usr/bin/env bash` and `set -euo pipefail`
2. Resolve SKILL_DIR via `$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)`
3. Create temp test directory: `TEST_LOG_DIR=$(mktemp -d "/tmp/gsd-test-XXXXXX")`
4. Trap cleanup: `trap 'rm -rf "$TEST_LOG_DIR"' EXIT`
5. Source the library: `source "${SKILL_DIR}/lib/hook-utils.sh"`

Test cases (each writes to the same JSONL file to also test append behavior):

**Test A — Basic record with clean strings:**
- Call write_hook_event_record with simple values: jsonl_file="${TEST_LOG_DIR}/test.jsonl", hook_entry_ms=$(date +%s%3N), hook_script="stop-hook.sh", session_name="test-session", agent_id="test-agent", openclaw_session_id="test-id-123", trigger="response_complete", state="working", content_source="transcript", wake_message="Hello world", response='{"status":"ok"}', outcome="delivered"
- Assert: file exists, exactly 1 line, `jq -e '.' "$JSONL_FILE"` succeeds (valid JSON)
- Assert: `jq -e '.duration_ms | type == "number"'` (integer, not string)
- Assert: `jq -e '.hook_script == "stop-hook.sh"'` (field correct)
- Assert: `jq -e '.outcome == "delivered"'` (field correct)

**Test B — Strings with newlines, quotes, and ANSI codes:**
- Call write_hook_event_record with wake_message containing: `$(printf 'line1\nline2 with "quotes"\nANSI: \033[31mred\033[0m')`
- Assert: `jq -e '.wake_message | contains("\\n")' "$JSONL_FILE"` (newlines preserved in JSON)
- Assert: `jq -e '.wake_message | contains("quotes")' "$JSONL_FILE"` (quotes survived)
- Assert: file now has exactly 2 lines (appended to same file)

**Test C — Empty response field:**
- Call write_hook_event_record with response="" and outcome="no_response"
- Assert: `jq -e '.response == ""'` (empty string, not null)
- Assert: `jq -e '.outcome == "no_response"'`
- Assert: file now has exactly 3 lines

**Test D — All records are valid JSONL (parse entire file):**
- Run: `jq -e '.' "$JSONL_FILE"` on the entire file (jq validates each line)
- Count lines: `wc -l < "$JSONL_FILE"` equals 3

Print "PASS: {test_name}" for each passing assertion. Print "FAIL: {test_name}" and `exit 1` on first failure. Final line: "All tests passed".

Use a helper function for assertions:
```bash
assert_jq() {
  local description="$1"
  local filter="$2"
  local file="$3"
  if jq -e "$filter" "$file" > /dev/null 2>&1; then
    printf 'PASS: %s\n' "$description"
  else
    printf 'FAIL: %s\n' "$description"
    exit 1
  fi
}
```
  </action>
  <verify>
Run: `bash tests/test-write-hook-event-record.sh` — must print all PASS lines and end with "All tests passed".
Run: `bash -n tests/test-write-hook-event-record.sh` — must exit 0 (no syntax errors).
  </verify>
  <done>Unit test script exists at tests/test-write-hook-event-record.sh, is executable, runs in isolation without tmux/openclaw/Claude Code, and all assertions pass — proving write_hook_event_record() produces valid JSONL with correct types, escaping, and atomic append.</done>
</task>

</tasks>

<verification>
1. `bash -n lib/hook-utils.sh` — syntax valid
2. `source lib/hook-utils.sh && type write_hook_event_record` — function defined
3. `bash tests/test-write-hook-event-record.sh` — all tests pass
4. Existing functions still work: `source lib/hook-utils.sh && type lookup_agent_in_registry && type extract_last_assistant_response && type extract_pane_diff && type format_ask_user_questions` — all four original functions still defined
</verification>

<success_criteria>
- write_hook_event_record() is appended to lib/hook-utils.sh without modifying existing functions
- Function takes 12 explicit parameters (no globals), uses jq --arg for strings and --argjson for duration_ms
- Atomic append via flock on .lock file
- Silent failure: jq error returns 0, flock timeout returns 0 — never crashes calling hook
- Unit test proves: valid JSONL, integer duration_ms, safe escaping of newlines/quotes/ANSI, empty field handling, append behavior
</success_criteria>

<output>
After completion, create `.planning/phases/08-jsonl-logging-foundation/08-01-SUMMARY.md`
</output>
