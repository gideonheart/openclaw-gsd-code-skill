---
phase: 03-stop-event-full-stack
plan: "02"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - events/stop/event_stop.mjs
  - events/stop/prompt_stop.md
  - bin/tui-driver.mjs
autonomous: true
requirements:
  - STOP-01
  - STOP-02
  - STOP-03
  - TUI-01
  - TUI-05

must_haves:
  truths:
    - "Stop handler extracts last_assistant_message and suggested_commands from hook JSON and wakes agent via gateway"
    - "Stop handler skips silently when stop_hook_active is true"
    - "Stop handler skips silently when session is not in agent-registry"
    - "Stop handler skips silently when last_assistant_message is empty or missing"
    - "Stop handler delegates to queue processor when queue file exists for session"
    - "Stop handler wakes agent with queue-complete summary when queue processor returns queue-complete"
    - "prompt_stop.md instructs agent to read response, decide commands, and call bin/tui-driver.mjs"
    - "bin/tui-driver.mjs accepts --session flag and JSON command array, creates queue file, and types first command"
  artifacts:
    - path: "events/stop/event_stop.mjs"
      provides: "Stop hook entry point"
    - path: "events/stop/prompt_stop.md"
      provides: "Agent decision prompt for Stop events"
      contains: "bin/tui-driver.mjs"
    - path: "bin/tui-driver.mjs"
      provides: "Generic TUI driver that creates queue and types first command"
  key_links:
    - from: "events/stop/event_stop.mjs"
      to: "lib/queue-processor.mjs"
      via: "import processQueueForHook"
      pattern: "import.*queue-processor"
    - from: "events/stop/event_stop.mjs"
      to: "lib/gateway.mjs"
      via: "import wakeAgentViaGateway"
      pattern: "import.*gateway|import.*index"
    - from: "events/stop/event_stop.mjs"
      to: "events/stop/prompt_stop.md"
      via: "promptFilePath resolved relative to handler"
      pattern: "prompt_stop\\.md"
    - from: "events/stop/prompt_stop.md"
      to: "bin/tui-driver.mjs"
      via: "instructs agent to call TUI driver"
      pattern: "bin/tui-driver\\.mjs"
    - from: "bin/tui-driver.mjs"
      to: "lib/tui-common.mjs"
      via: "import typeCommandIntoTmuxSession"
      pattern: "import.*tui-common"
---

<objective>
Build the Stop event handler with its prompt template and the generic TUI driver. The handler is the main entry point for the Stop hook: it extracts content, resolves the agent, and either wakes the agent (no queue) or advances the queue (queue exists). The TUI driver is the script the agent calls to create a command queue and type the first command.

Purpose: This plan delivers the two user-facing artifacts that make the Stop event work end-to-end: the handler that Claude Code invokes, and the TUI driver that the orchestrating agent calls.
Output: events/stop/event_stop.mjs, events/stop/prompt_stop.md, bin/tui-driver.mjs
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stop-event-full-stack/03-CONTEXT.md
@.planning/phases/03-stop-event-full-stack/03-01-SUMMARY.md

# Lib modules this plan depends on
@lib/tui-common.mjs
@lib/queue-processor.mjs
@lib/gateway.mjs
@lib/agent-resolver.mjs
@lib/json-extractor.mjs
@lib/paths.mjs
@lib/index.mjs

# Existing bin script for pattern reference
@bin/launch-session.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events/stop/event_stop.mjs and events/stop/prompt_stop.md</name>
  <files>events/stop/event_stop.mjs, events/stop/prompt_stop.md</files>
  <action>
**Create `events/stop/event_stop.mjs`** — the Stop hook handler entry point.

This handler reads JSON from stdin (Claude Code pipes hook payload) and either wakes the agent or advances an existing queue.

**Stdin reading pattern:**
```javascript
import { readFileSync } from 'node:fs';
const rawStdin = readFileSync('/dev/stdin', 'utf8').trim();
```

**Step-by-step logic:**

1. Read stdin as raw JSON string
2. Parse the full JSON payload: `const hookPayload = JSON.parse(rawStdin);`
3. **Guard: stop_hook_active** — if `hookPayload.stop_hook_active === true`, exit 0 silently. This is the re-entrancy guard. Optionally log at debug level (Claude's discretion per CONTEXT.md).
4. **Resolve tmux session name** — Claude Code's hook JSON contains `session_id` (a UUID), NOT the tmux session name. The handler runs inside the tmux session, so get the session name the same way hook-event-logger.sh does (line 35):
   ```javascript
   import { execFileSync } from 'node:child_process';
   const sessionName = execFileSync('tmux', ['display-message', '-p', '#S'], { encoding: 'utf8' }).trim();
   ```
   If empty string (not running in tmux), exit 0 silently — this is an unmanaged session.
5. **Guard: resolve agent** — call `resolveAgentFromSession(sessionName)`. If null, exit 0 silently.
6. Extract `lastAssistantMessage` from `hookPayload.last_assistant_message`. **Guard:** if empty/falsy, exit 0 silently.
7. **Check for existing queue** — call `processQueueForHook(sessionName, 'Stop', null, lastAssistantMessage)`.
   - If result.action is `'advanced'`: queue was advanced, exit 0.
   - If result.action is `'queue-complete'`: wake agent with queue-complete summary (see below), exit 0.
   - If result.action is `'no-queue'`: continue to step 8 (wake agent fresh).
   - If result.action is `'awaits-mismatch'`: exit 0 silently (Stop fired but queue expects a different hook).
   - If result.action is `'no-active-command'`: exit 0 silently.
8. **Extract suggested commands** from `lastAssistantMessage`:
   ```javascript
   const commandMatches = lastAssistantMessage.match(/\/(?:gsd:[a-z-]+(?:\s+[^\s`]+)?|clear)/g) || [];
   const suggestedCommands = [...new Set(commandMatches)];
   ```
9. **Build content for gateway** — following the established Phase 2 pattern (metadata first, content second, instructions last is handled by `wakeAgentViaGateway`). The messageContent should include both the last_assistant_message and the suggested_commands:
   ```javascript
   const messageContent = [
     lastAssistantMessage,
     '',
     '## Suggested Commands',
     suggestedCommands.length > 0
       ? suggestedCommands.map(cmd => `- \`${cmd}\``).join('\n')
       : '_No commands detected in response._',
   ].join('\n');
   ```
10. **Wake agent via gateway:**
    ```javascript
    const promptFilePath = resolve(dirname(fileURLToPath(import.meta.url)), 'prompt_stop.md');
    wakeAgentViaGateway({
      openclawSessionId: resolvedAgent.openclaw_session_id,
      messageContent,
      promptFilePath,
      eventMetadata: {
        eventType: 'Stop',
        sessionName,
        timestamp: new Date().toISOString(),
      },
      sessionName,
    });
    ```

**Queue-complete wake:** When `processQueueForHook` returns `{ action: 'queue-complete', summary }`, convert the summary object to a string before passing to `wakeAgentViaGateway` (which requires `messageContent` to be a string):
    ```javascript
    const messageContent = JSON.stringify(result.summary, null, 2);
    ```
    Use the same `prompt_stop.md` as the prompt. Per CONTEXT.md, this is an implementation decision — use `prompt_stop.md` with the summary as content (the prompt already has "When to do nothing" guidance, which covers this case).

Wrap the main logic in an async IIFE or `main().catch()` pattern (per Phase 01.1 established pattern). The handler must exit cleanly — `process.exit(0)` on success, let unhandled errors propagate (Claude Code's hook runner handles non-zero exits).

**Imports:** `readFileSync` from `node:fs`, `execFileSync` from `node:child_process`, `resolve`, `dirname` from `node:path`, `fileURLToPath` from `node:url`, and from `../../lib/index.mjs`: `resolveAgentFromSession`, `wakeAgentViaGateway`, `processQueueForHook`, `appendJsonlEntry`.

---

**Create `events/stop/prompt_stop.md`** — the agent decision prompt.

Use the exact structure from CONTEXT.md Section 3, which is the locked decision. Content:

```markdown
# Stop Event

Claude Code has stopped and is waiting for input.

## What you received
- `last_assistant_message`: Claude Code's final response before stopping
- `suggested_commands`: Commands extracted from the response (any /gsd:* and /clear found in the text)

## What to do
1. Read the message. Understand what Claude Code just finished or why it stopped.
2. Review `suggested_commands` — these are what Claude Code recommended, but you decide.
   - You may use them as-is, reorder them, skip some, or choose entirely different commands.
   - They are suggestions, not instructions.
3. Decide your command array and call the TUI driver:
   ```
   node bin/tui-driver.mjs --session <session-name> '["/clear", "/gsd:plan-phase 3"]'
   ```
   Note: the session name is provided in the Event Metadata above — use that session value.

## Command types and their awaits
- `/gsd:*` commands -> Claude responds -> awaits Stop
- `/clear` -> clears context -> awaits SessionStart(source:clear)
- The TUI driver handles awaits automatically.

## When to do nothing
- If the work is complete and no next phase exists, respond with no commands.
- If you received a queue-complete summary, review the results and decide if more work is needed.
- The queue will not be created and the session stays idle.
```
  </action>
  <verify>Run `node --check events/stop/event_stop.mjs` — must exit 0 with no syntax errors. Verify `events/stop/prompt_stop.md` exists and contains "bin/tui-driver.mjs".</verify>
  <done>events/stop/event_stop.mjs reads stdin JSON, guards against stop_hook_active/missing-agent/empty-message, delegates to queue processor or wakes agent with content + prompt. events/stop/prompt_stop.md instructs agent to decide commands and call bin/tui-driver.mjs.</done>
</task>

<task type="auto">
  <name>Task 2: Create bin/tui-driver.mjs — generic TUI command driver</name>
  <files>bin/tui-driver.mjs</files>
  <action>
Create `bin/tui-driver.mjs` — the generic TUI driver that the agent calls to create a command queue and type the first command into tmux.

**CLI interface:**
```
node bin/tui-driver.mjs --session <session-name> '<json-command-array>'
```

Example: `node bin/tui-driver.mjs --session warden-main-4 '["/clear", "/gsd:plan-phase 3"]'`

**Argument parsing:** Use `parseArgs` from `node:util` (Phase 01.1 pattern):
```javascript
import { parseArgs } from 'node:util';
const { values, positionals } = parseArgs({
  options: {
    session: { type: 'string', short: 's' },
  },
  allowPositionals: true,
});
```
- `values.session` is the tmux session name (required)
- `positionals[0]` is the JSON command array string (required)

**Step-by-step logic:**

1. Parse arguments. Guard: exit with error if `--session` or command array positional is missing.
2. Parse the JSON command array: `const commandTexts = JSON.parse(positionals[0]);`
   Guard: exit with error if not a non-empty array of strings.
3. Build the queue data structure per CONTEXT.md queue file schema:
   ```javascript
   const queueData = {
     commands: commandTexts.map((commandText, index) => ({
       id: index + 1,
       command: commandText,
       status: index === 0 ? 'active' : 'pending',
       awaits: resolveAwaitsForCommand(commandText),
       result: null,
       completed_at: null,
     })),
   };
   ```
4. Implement `resolveAwaitsForCommand(commandText)` using the command-to-awaits mapping from CONTEXT.md:
   - `/clear` -> `{ hook: 'SessionStart', sub: 'clear' }`
   - `/gsd:*` -> `{ hook: 'Stop', sub: null }`
   - Anything else -> `{ hook: 'Stop', sub: null }` (safe default)
5. Write queue file atomically: write to `.tmp`, rename. Path: `logs/queues/queue-{sessionName}.json`. Ensure `logs/queues/` directory exists (mkdirSync recursive).
6. Type the first command into tmux via `typeCommandIntoTmuxSession(sessionName, commandTexts[0])`.
7. Log the queue creation via `appendJsonlEntry` at info level.
8. Exit 0 (fire-and-forget).

**Make the file executable:** Add shebang `#!/usr/bin/env node` at the top.

**Imports:** `parseArgs` from `node:util`, `writeFileSync`, `renameSync`, `mkdirSync` from `node:fs`, `resolve` from `node:path`, `fileURLToPath` from `node:url`, `typeCommandIntoTmuxSession` from `../lib/tui-common.mjs`, `appendJsonlEntry` from `../lib/logger.mjs`, and compute SKILL_ROOT via `dirname(dirname(fileURLToPath(import.meta.url)))` (bin scripts compute their own root — they are entry points, not lib modules).

Follow bin/ patterns from `launch-session.mjs`: shebang, parseArgs, async main with catch, self-explanatory naming, no abbreviations.
  </action>
  <verify>Run `node --check bin/tui-driver.mjs` — must exit 0 with no syntax errors. Run `chmod +x bin/tui-driver.mjs && ls -la bin/tui-driver.mjs` to verify it is executable.</verify>
  <done>bin/tui-driver.mjs accepts --session and JSON command array, creates queue file with proper awaits mapping, types first command into tmux, exits. File is executable with shebang.</done>
</task>

</tasks>

<verification>
1. `node --check events/stop/event_stop.mjs` exits 0
2. `node --check bin/tui-driver.mjs` exits 0
3. `events/stop/prompt_stop.md` exists and references `bin/tui-driver.mjs`
4. `bin/tui-driver.mjs` is executable (`chmod +x`)
5. Stop handler imports from `../../lib/index.mjs` (correct relative path from events/stop/)
6. Stop handler reads `prompt_stop.md` via resolve + dirname + import.meta.url (at call time, not cached)
7. TUI driver uses parseArgs from node:util (Phase 01.1 pattern)
8. TUI driver writes queue atomically (tmp + rename)
</verification>

<success_criteria>
- events/stop/event_stop.mjs handles all filtering cases: stop_hook_active, missing agent, empty message, existing queue
- events/stop/prompt_stop.md matches CONTEXT.md Section 3 structure and references bin/tui-driver.mjs
- bin/tui-driver.mjs creates queue file and types first command
- All files pass `node --check`
- No new external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-stop-event-full-stack/03-02-SUMMARY.md`
</output>
