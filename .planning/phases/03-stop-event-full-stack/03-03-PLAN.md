---
phase: 03-stop-event-full-stack
plan: "03"
type: execute
wave: 3
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - events/session_start/event_session_start.mjs
  - events/user_prompt_submit/event_user_prompt_submit.mjs
  - README.md
autonomous: true
requirements:
  - ARCH-04

must_haves:
  truths:
    - "SessionStart handler advances queue when source is clear and queue exists with active command awaiting SessionStart"
    - "SessionStart handler cleans up stale queue when source is startup"
    - "SessionStart handler does nothing when no queue exists"
    - "UserPromptSubmit handler cancels queue when queue exists for the session"
    - "UserPromptSubmit handler does nothing when no queue exists"
    - "UserPromptSubmit handler wakes agent with cancellation summary"
    - "SessionStart and UserPromptSubmit handlers reuse prompt_stop.md — no dedicated prompt is needed for pure queue-advance handlers per CONTEXT.md Section 3"
    - "README.md documents manual hook registration entries for settings.json: Stop (timeout 30), SessionStart (timeout 30), UserPromptSubmit (timeout 10)"
  artifacts:
    - path: "events/session_start/event_session_start.mjs"
      provides: "SessionStart hook entry point for /clear completion and stale cleanup"
    - path: "events/user_prompt_submit/event_user_prompt_submit.mjs"
      provides: "UserPromptSubmit hook entry point for queue cancellation on manual input"
    - path: "README.md"
      provides: "Manual hook registration instructions for settings.json"
      contains: "settings.json"
  key_links:
    - from: "events/session_start/event_session_start.mjs"
      to: "lib/queue-processor.mjs"
      via: "import processQueueForHook, cleanupStaleQueueForSession"
      pattern: "import.*queue-processor"
    - from: "events/user_prompt_submit/event_user_prompt_submit.mjs"
      to: "lib/queue-processor.mjs"
      via: "import cancelQueueForSession"
      pattern: "import.*queue-processor"
    - from: "events/user_prompt_submit/event_user_prompt_submit.mjs"
      to: "lib/gateway.mjs"
      via: "import wakeAgentViaGateway for cancellation notification"
      pattern: "import.*gateway|import.*index"
---

<objective>
Build the two supporting event handlers that complete the queue lifecycle: SessionStart (advances queue after `/clear` completes, cleans stale queues on startup) and UserPromptSubmit (cancels active queue when user types manually). Also document the manual hook registration entries in README.md so handlers can be tested.

Purpose: Without these handlers, the queue system cannot advance after `/clear` commands and cannot be cancelled when the user takes manual control. They complete the event-driven queue lifecycle. Without registration documentation, handlers cannot fire and the phase cannot be validated.
Output: events/session_start/event_session_start.mjs, events/user_prompt_submit/event_user_prompt_submit.mjs, README.md (updated with registration section)
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stop-event-full-stack/03-CONTEXT.md
@.planning/phases/03-stop-event-full-stack/03-01-SUMMARY.md

# Lib modules these handlers use
@lib/queue-processor.mjs
@lib/gateway.mjs
@lib/agent-resolver.mjs
@lib/index.mjs

</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events/session_start/event_session_start.mjs</name>
  <files>events/session_start/event_session_start.mjs</files>
  <action>
Create `events/session_start/event_session_start.mjs` — the SessionStart hook handler.

This is a thin entry point (~15-20 lines of logic) that handles two scenarios:

**Stdin reading:** Same pattern as Stop handler — `readFileSync('/dev/stdin', 'utf8').trim()`, then `JSON.parse()`.

**Step-by-step logic:**

1. Read and parse stdin JSON payload
2. Extract `sessionName` from the payload (same field as Stop handler)
3. Extract `source` from the payload — Claude Code's SessionStart hook includes a `source` field indicating why the session started (`"startup"`, `"clear"`, etc.)
4. **Guard: resolve agent** — call `resolveAgentFromSession(sessionName)`. If null, exit 0 silently. (Not every session is managed.)

**Branch on source:**

**If `source === 'clear'`:**
- Call `processQueueForHook(sessionName, 'SessionStart', 'clear', null)`.
  - `lastAssistantMessage` is null because `/clear` produces no assistant message.
- Handle result same as Stop handler:
  - `'advanced'`: queue was advanced, exit 0.
  - `'queue-complete'`: convert the summary object to a string via `const messageContent = JSON.stringify(result.summary, null, 2);`, then wake agent (same pattern as Stop handler — call `wakeAgentViaGateway` with `messageContent` and prompt). For simplicity, use the same prompt_stop.md from `events/stop/` — it already has "When to do nothing" guidance. Resolve path: `resolve(dirname(fileURLToPath(import.meta.url)), '..', 'stop', 'prompt_stop.md')`.
  - `'no-queue'`, `'awaits-mismatch'`, `'no-active-command'`: exit 0 silently.

**If `source === 'startup'`:**
- Call `cleanupStaleQueueForSession(sessionName)`.
- If returned `true` (stale queue found and renamed): wake agent with message "Previous session had unfinished queue. Stale queue archived."
  - Use `wakeAgentViaGateway` with a brief informational message as content and `prompt_stop.md` as the prompt (reuse existing prompt).
- If returned `false` (no queue existed): exit 0 silently. Clean start.

**For any other source value:** exit 0 silently (no queue interaction needed).

**Imports:** `readFileSync` from `node:fs`, `resolve`, `dirname` from `node:path`, `fileURLToPath` from `node:url`, and from `../../lib/index.mjs`: `resolveAgentFromSession`, `wakeAgentViaGateway`, `processQueueForHook`, `cleanupStaleQueueForSession`, `appendJsonlEntry`.

Wrap in async main with catch pattern. Exit 0 on success.
  </action>
  <verify>Run `node --check events/session_start/event_session_start.mjs` — must exit 0 with no syntax errors.</verify>
  <done>events/session_start/event_session_start.mjs handles source:clear (advance queue) and source:startup (stale cleanup) scenarios. Thin entry point calling shared queue-processor functions.</done>
</task>

<task type="auto">
  <name>Task 2: Create events/user_prompt_submit/event_user_prompt_submit.mjs</name>
  <files>events/user_prompt_submit/event_user_prompt_submit.mjs</files>
  <action>
Create `events/user_prompt_submit/event_user_prompt_submit.mjs` — the UserPromptSubmit hook handler.

This is the thinnest handler (~10-15 lines of logic). It cancels any active queue when the user types manually.

**Step-by-step logic:**

1. Read and parse stdin JSON payload (same pattern)
2. Extract `sessionName` from the payload
3. **Guard: resolve agent** — call `resolveAgentFromSession(sessionName)`. If null, exit 0 silently.
4. Call `cancelQueueForSession(sessionName)`
5. If result is `false` (no queue existed): exit 0 silently. Nothing to cancel.
6. If result has `cancelled: true`: wake agent with cancellation notification:
   - Build messageContent summarizing what was cancelled:
     ```
     Queue cancelled by manual input.
     Completed: {completedCount}/{totalCount} commands.
     Remaining commands: {remainingCommands.map(c => c.command).join(', ')}
     ```
   - Use `wakeAgentViaGateway` with `prompt_stop.md` from `events/stop/` as the prompt (same reuse pattern as session_start handler).
   - Resolve path: `resolve(dirname(fileURLToPath(import.meta.url)), '..', 'stop', 'prompt_stop.md')`

**Imports:** `readFileSync` from `node:fs`, `resolve`, `dirname` from `node:path`, `fileURLToPath` from `node:url`, and from `../../lib/index.mjs`: `resolveAgentFromSession`, `wakeAgentViaGateway`, `cancelQueueForSession`, `appendJsonlEntry`.

Wrap in async main with catch pattern. Exit 0 on success.
  </action>
  <verify>Run `node --check events/user_prompt_submit/event_user_prompt_submit.mjs` — must exit 0 with no syntax errors.</verify>
  <done>events/user_prompt_submit/event_user_prompt_submit.mjs cancels queue on manual input and wakes agent with cancellation summary. Thin entry point (~10-15 lines of logic).</done>
</task>

<task type="auto">
  <name>Task 3: Document manual hook registration in README.md</name>
  <files>README.md</files>
  <action>
Add a "Hook Registration" section to `README.md` documenting the three `settings.json` entries required for Phase 3 handlers to fire. Per CONTEXT.md Section 5, Phase 3 delivers manual registration documented in README; Phase 5 delivers the automated registration script.

**Add a section (e.g., `## Hook Registration`) with the following content:**

Users must add these entries to `~/.claude/settings.json` under the appropriate hook arrays. Provide the exact JSON entries:

**Stop hook** (timeout: 30 seconds):
```json
{
  "hooks": {
    "Stop": [
      {
        "type": "command",
        "command": "node /absolute/path/to/events/stop/event_stop.mjs",
        "timeout": 30000
      }
    ]
  }
}
```

**SessionStart hook** (timeout: 30 seconds):
```json
{
  "hooks": {
    "SessionStart": [
      {
        "type": "command",
        "command": "node /absolute/path/to/events/session_start/event_session_start.mjs",
        "timeout": 30000
      }
    ]
  }
}
```

**UserPromptSubmit hook** (timeout: 10 seconds):
```json
{
  "hooks": {
    "UserPromptSubmit": [
      {
        "type": "command",
        "command": "node /absolute/path/to/events/user_prompt_submit/event_user_prompt_submit.mjs",
        "timeout": 10000
      }
    ]
  }
}
```

**Notes to include:**
- Use absolute paths to the handler scripts (relative to the skill's installation directory)
- The existing `hook-event-logger.sh` entries should remain alongside these — they provide debug logging
- Timeouts are in milliseconds: Stop and SessionStart at 30000ms, UserPromptSubmit at 10000ms (must be fast since it fires on every user input)
- Phase 5 will deliver an automated registration script that manages these entries

Read the existing README.md first to determine the best location for this section. Place it after any existing "Usage" or "Setup" section.
  </action>
  <verify>Verify that README.md contains "settings.json", "Stop", "SessionStart", "UserPromptSubmit", "timeout", and "event_stop.mjs" references. Run `grep -c 'settings.json' README.md` — must return at least 1.</verify>
  <done>README.md contains a Hook Registration section documenting all three settings.json entries with correct handler paths and timeouts (Stop 30s, SessionStart 30s, UserPromptSubmit 10s).</done>
</task>

</tasks>

<verification>
1. `node --check events/session_start/event_session_start.mjs` exits 0
2. `node --check events/user_prompt_submit/event_user_prompt_submit.mjs` exits 0
3. Both handlers import from `../../lib/index.mjs` (correct relative path from events/{hook_name}/)
4. Both handlers follow the same stdin-reading pattern as event_stop.mjs
5. SessionStart handler branches on source field: 'clear' -> advance, 'startup' -> stale cleanup
6. UserPromptSubmit handler cancels queue and wakes agent with summary
7. Both handlers are thin — majority of logic lives in lib/queue-processor.mjs
8. README.md contains Hook Registration section with all three settings.json entries and correct timeouts
</verification>

<success_criteria>
- events/session_start/event_session_start.mjs exists and handles clear/startup/other source values
- events/user_prompt_submit/event_user_prompt_submit.mjs exists and cancels queue on manual input
- Both files pass `node --check`
- Both follow established patterns: stdin reading, guard clauses, async main with catch
- README.md documents manual hook registration for Stop (30s), SessionStart (30s), UserPromptSubmit (10s) with correct handler paths
- No new external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-stop-event-full-stack/03-03-SUMMARY.md`
</output>
