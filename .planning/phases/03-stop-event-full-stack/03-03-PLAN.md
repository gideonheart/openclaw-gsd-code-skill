---
phase: 03-stop-event-full-stack
plan: "03"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - events/session_start/event_session_start.mjs
  - events/user_prompt_submit/event_user_prompt_submit.mjs
autonomous: true
requirements:
  - ARCH-04

must_haves:
  truths:
    - "SessionStart handler advances queue when source is clear and queue exists with active command awaiting SessionStart"
    - "SessionStart handler cleans up stale queue when source is startup"
    - "SessionStart handler does nothing when no queue exists"
    - "UserPromptSubmit handler cancels queue when queue exists for the session"
    - "UserPromptSubmit handler does nothing when no queue exists"
    - "UserPromptSubmit handler wakes agent with cancellation summary"
  artifacts:
    - path: "events/session_start/event_session_start.mjs"
      provides: "SessionStart hook entry point for /clear completion and stale cleanup"
    - path: "events/user_prompt_submit/event_user_prompt_submit.mjs"
      provides: "UserPromptSubmit hook entry point for queue cancellation on manual input"
  key_links:
    - from: "events/session_start/event_session_start.mjs"
      to: "lib/queue-processor.mjs"
      via: "import processQueueForHook, cleanupStaleQueueForSession"
      pattern: "import.*queue-processor"
    - from: "events/user_prompt_submit/event_user_prompt_submit.mjs"
      to: "lib/queue-processor.mjs"
      via: "import cancelQueueForSession"
      pattern: "import.*queue-processor"
    - from: "events/user_prompt_submit/event_user_prompt_submit.mjs"
      to: "lib/gateway.mjs"
      via: "import wakeAgentViaGateway for cancellation notification"
      pattern: "import.*gateway|import.*index"
---

<objective>
Build the two supporting event handlers that complete the queue lifecycle: SessionStart (advances queue after `/clear` completes, cleans stale queues on startup) and UserPromptSubmit (cancels active queue when user types manually).

Purpose: Without these handlers, the queue system cannot advance after `/clear` commands and cannot be cancelled when the user takes manual control. They complete the event-driven queue lifecycle.
Output: events/session_start/event_session_start.mjs, events/user_prompt_submit/event_user_prompt_submit.mjs
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stop-event-full-stack/03-CONTEXT.md
@.planning/phases/03-stop-event-full-stack/03-01-SUMMARY.md

# Lib modules these handlers use
@lib/queue-processor.mjs
@lib/gateway.mjs
@lib/agent-resolver.mjs
@lib/index.mjs

# Pattern reference — the Stop handler from Plan 02
@events/stop/event_stop.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events/session_start/event_session_start.mjs</name>
  <files>events/session_start/event_session_start.mjs</files>
  <action>
Create `events/session_start/event_session_start.mjs` — the SessionStart hook handler.

This is a thin entry point (~15-20 lines of logic) that handles two scenarios:

**Stdin reading:** Same pattern as Stop handler — `readFileSync('/dev/stdin', 'utf8').trim()`, then `JSON.parse()`.

**Step-by-step logic:**

1. Read and parse stdin JSON payload
2. Extract `sessionName` from the payload (same field as Stop handler)
3. Extract `source` from the payload — Claude Code's SessionStart hook includes a `source` field indicating why the session started (`"startup"`, `"clear"`, etc.)
4. **Guard: resolve agent** — call `resolveAgentFromSession(sessionName)`. If null, exit 0 silently. (Not every session is managed.)

**Branch on source:**

**If `source === 'clear'`:**
- Call `processQueueForHook(sessionName, 'SessionStart', 'clear', null)`.
  - `lastAssistantMessage` is null because `/clear` produces no assistant message.
- Handle result same as Stop handler:
  - `'advanced'`: queue was advanced, exit 0.
  - `'queue-complete'`: wake agent with summary (same pattern as Stop handler — call `wakeAgentViaGateway` with the summary as messageContent and any appropriate prompt). For simplicity, use the same prompt_stop.md from `events/stop/` — it already has "When to do nothing" guidance. Resolve path: `resolve(dirname(fileURLToPath(import.meta.url)), '..', 'stop', 'prompt_stop.md')`.
  - `'no-queue'`, `'awaits-mismatch'`, `'no-active-command'`: exit 0 silently.

**If `source === 'startup'`:**
- Call `cleanupStaleQueueForSession(sessionName)`.
- If returned `true` (stale queue found and renamed): wake agent with message "Previous session had unfinished queue. Stale queue archived."
  - Use `wakeAgentViaGateway` with a brief informational message as content and `prompt_stop.md` as the prompt (reuse existing prompt).
- If returned `false` (no queue existed): exit 0 silently. Clean start.

**For any other source value:** exit 0 silently (no queue interaction needed).

**Imports:** `readFileSync` from `node:fs`, `resolve`, `dirname` from `node:path`, `fileURLToPath` from `node:url`, and from `../../lib/index.mjs`: `resolveAgentFromSession`, `wakeAgentViaGateway`, `processQueueForHook`, `cleanupStaleQueueForSession`, `appendJsonlEntry`.

Wrap in async main with catch pattern. Exit 0 on success.
  </action>
  <verify>Run `node --check events/session_start/event_session_start.mjs` — must exit 0 with no syntax errors.</verify>
  <done>events/session_start/event_session_start.mjs handles source:clear (advance queue) and source:startup (stale cleanup) scenarios. Thin entry point calling shared queue-processor functions.</done>
</task>

<task type="auto">
  <name>Task 2: Create events/user_prompt_submit/event_user_prompt_submit.mjs</name>
  <files>events/user_prompt_submit/event_user_prompt_submit.mjs</files>
  <action>
Create `events/user_prompt_submit/event_user_prompt_submit.mjs` — the UserPromptSubmit hook handler.

This is the thinnest handler (~10-15 lines of logic). It cancels any active queue when the user types manually.

**Step-by-step logic:**

1. Read and parse stdin JSON payload (same pattern)
2. Extract `sessionName` from the payload
3. **Guard: resolve agent** — call `resolveAgentFromSession(sessionName)`. If null, exit 0 silently.
4. Call `cancelQueueForSession(sessionName)`
5. If result is `false` (no queue existed): exit 0 silently. Nothing to cancel.
6. If result has `cancelled: true`: wake agent with cancellation notification:
   - Build messageContent summarizing what was cancelled:
     ```
     Queue cancelled by manual input.
     Completed: {completedCount}/{totalCount} commands.
     Remaining commands: {remainingCommands.map(c => c.command).join(', ')}
     ```
   - Use `wakeAgentViaGateway` with `prompt_stop.md` from `events/stop/` as the prompt (same reuse pattern as session_start handler).
   - Resolve path: `resolve(dirname(fileURLToPath(import.meta.url)), '..', 'stop', 'prompt_stop.md')`

**Imports:** `readFileSync` from `node:fs`, `resolve`, `dirname` from `node:path`, `fileURLToPath` from `node:url`, and from `../../lib/index.mjs`: `resolveAgentFromSession`, `wakeAgentViaGateway`, `cancelQueueForSession`, `appendJsonlEntry`.

Wrap in async main with catch pattern. Exit 0 on success.
  </action>
  <verify>Run `node --check events/user_prompt_submit/event_user_prompt_submit.mjs` — must exit 0 with no syntax errors.</verify>
  <done>events/user_prompt_submit/event_user_prompt_submit.mjs cancels queue on manual input and wakes agent with cancellation summary. Thin entry point (~10-15 lines of logic).</done>
</task>

</tasks>

<verification>
1. `node --check events/session_start/event_session_start.mjs` exits 0
2. `node --check events/user_prompt_submit/event_user_prompt_submit.mjs` exits 0
3. Both handlers import from `../../lib/index.mjs` (correct relative path from events/{hook_name}/)
4. Both handlers follow the same stdin-reading pattern as event_stop.mjs
5. SessionStart handler branches on source field: 'clear' -> advance, 'startup' -> stale cleanup
6. UserPromptSubmit handler cancels queue and wakes agent with summary
7. Both handlers are thin — majority of logic lives in lib/queue-processor.mjs
</verification>

<success_criteria>
- events/session_start/event_session_start.mjs exists and handles clear/startup/other source values
- events/user_prompt_submit/event_user_prompt_submit.mjs exists and cancels queue on manual input
- Both files pass `node --check`
- Both follow established patterns: stdin reading, guard clauses, async main with catch
- No new external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-stop-event-full-stack/03-03-SUMMARY.md`
</output>
