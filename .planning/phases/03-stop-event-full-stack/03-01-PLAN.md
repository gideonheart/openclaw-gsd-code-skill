---
phase: 03-stop-event-full-stack
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/tui-common.mjs
  - lib/queue-processor.mjs
  - lib/index.mjs
autonomous: true
requirements:
  - ARCH-04
  - TUI-02

must_haves:
  truths:
    - "tmux send-keys wrapper types text into a named tmux session pane"
    - "tmux send-keys wrapper handles slash-command typing with Tab completion and Enter"
    - "Queue processor reads a queue file, matches incoming hook against active command awaits, and advances or completes the queue"
    - "Queue processor wakes agent via gateway on queue completion with summary payload"
    - "Queue processor cancels queue by renaming to .stale.json"
    - "Queue processor handles stale cleanup on session startup"
    - "lib/index.mjs re-exports both new modules alongside existing exports"
  artifacts:
    - path: "lib/tui-common.mjs"
      provides: "tmux send-keys wrapper for typing commands with Tab+Enter"
      exports: ["typeCommandIntoTmuxSession"]
    - path: "lib/queue-processor.mjs"
      provides: "Shared queue read/advance/complete/cancel logic"
      exports: ["processQueueForHook", "cancelQueueForSession", "cleanupStaleQueueForSession"]
    - path: "lib/index.mjs"
      provides: "Unified re-export entry point including new modules"
  key_links:
    - from: "lib/queue-processor.mjs"
      to: "lib/tui-common.mjs"
      via: "import typeCommandIntoTmuxSession"
      pattern: "import.*tui-common"
    - from: "lib/queue-processor.mjs"
      to: "lib/gateway.mjs"
      via: "import wakeAgentViaGateway for queue-complete notification"
      pattern: "import.*gateway"
    - from: "lib/index.mjs"
      to: "lib/queue-processor.mjs"
      via: "re-export"
      pattern: "export.*queue-processor"
---

<objective>
Build the two new shared lib modules that all Phase 3 event handlers and the TUI driver depend on: a tmux send-keys wrapper (`lib/tui-common.mjs`) and a hook-agnostic queue processor (`lib/queue-processor.mjs`). Update `lib/index.mjs` to re-export the new modules.

Purpose: These modules are the shared foundation for the entire Stop event pipeline. The TUI driver and all three event handlers (stop, session_start, user_prompt_submit) depend on them.
Output: Two new lib modules + updated barrel export file.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stop-event-full-stack/03-CONTEXT.md

# Existing lib modules — follow the same patterns
@lib/paths.mjs
@lib/logger.mjs
@lib/gateway.mjs
@lib/agent-resolver.mjs
@lib/index.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/tui-common.mjs — tmux send-keys wrapper</name>
  <files>lib/tui-common.mjs</files>
  <action>
Create `lib/tui-common.mjs` that exports a single function `typeCommandIntoTmuxSession()`.

This function handles all tmux TUI mechanics for typing a slash command:

**Parameters:**
- `tmuxSessionName` (string, required) — the tmux session to type into
- `commandText` (string, required) — the full command text (e.g., `/gsd:plan-phase 3` or `/clear`)

**Behavior:**
1. Guard clause: throw if `tmuxSessionName` or `commandText` is missing/empty
2. Use `execFileSync` with argument arrays (Phase 01.1 pattern — never string interpolation into shell)
3. For `/gsd:*` commands: type the command prefix (e.g., `/gsd:plan`), send `Tab` key for tab-completion, then type any arguments after the command name, then send `Enter`
4. For `/clear`: type `/clear` then send `Enter` (no tab-completion needed)
5. Add a small delay between send-keys calls using `Atomics.wait` on a `SharedArrayBuffer` (synchronous sleep without spawning a process — Node 22+ supports this). Use 100ms between keystrokes for tmux reliability.
6. Log the typed command via `appendJsonlEntry` at info level with source `typeCommandIntoTmuxSession`

**tmux send-keys pattern:**
```javascript
execFileSync('tmux', ['send-keys', '-t', tmuxSessionName, textToType, ''], { stdio: 'pipe' });
// For special keys:
execFileSync('tmux', ['send-keys', '-t', tmuxSessionName, 'Tab'], { stdio: 'pipe' });
execFileSync('tmux', ['send-keys', '-t', tmuxSessionName, 'Enter'], { stdio: 'pipe' });
```

**Tab-completion logic for /gsd:* commands:**
- Split the command: everything up to and including the first space-delimited token is the "command name" (e.g., `/gsd:plan-phase`), everything after is "arguments" (e.g., `3`)
- Type the command name literal text
- Send Tab (triggers Claude Code's slash-command autocomplete)
- Wait 100ms
- If arguments exist, type a space then the arguments
- Send Enter

**Imports:** Use `execFileSync` from `node:child_process`, `appendJsonlEntry` from `./logger.mjs`.

Follow existing lib patterns: JSDoc on all exports, self-explanatory naming, no abbreviations, guard clauses throw for must-not-silently-fail operations.
  </action>
  <verify>Run `node --check lib/tui-common.mjs` — must exit 0 with no syntax errors.</verify>
  <done>lib/tui-common.mjs exports typeCommandIntoTmuxSession() that uses execFileSync to type commands into tmux with Tab completion for /gsd:* and Enter to submit.</done>
</task>

<task type="auto">
  <name>Task 2: Create lib/queue-processor.mjs and update lib/index.mjs</name>
  <files>lib/queue-processor.mjs, lib/index.mjs</files>
  <action>
Create `lib/queue-processor.mjs` that exports three functions: `processQueueForHook()`, `cancelQueueForSession()`, and `cleanupStaleQueueForSession()`.

**Queue file location:** `logs/queues/queue-{sessionName}.json` — use `SKILL_ROOT` from `lib/paths.mjs` to resolve.

**Atomic write helper (internal, not exported):**
Create `writeQueueFileAtomically(queueFilePath, queueData)` — writes to `{queueFilePath}.tmp`, then renames. Import `writeFileSync`, `renameSync`, `readFileSync`, `existsSync` from `node:fs`. Import `resolve`, `dirname` from `node:path`. Import `mkdirSync` from `node:fs` (ensure `logs/queues/` exists).

**Function 1: `processQueueForHook(sessionName, incomingHookName, incomingHookSubtype, lastAssistantMessage)`**

1. Guard: return `{ action: 'no-queue' }` if no queue file exists for this session
2. Read and parse the queue file
3. Find the command with `status: 'active'`
4. If no active command found, return `{ action: 'no-active-command' }`
5. Check if the incoming hook matches the active command's `awaits`:
   - `incomingHookName === activeCommand.awaits.hook`
   - AND (`activeCommand.awaits.sub === null` OR `incomingHookSubtype === activeCommand.awaits.sub`)
6. If no match, return `{ action: 'awaits-mismatch' }`
7. If match: mark active command as `done`, set `result` to `lastAssistantMessage` (or null if not provided), set `completed_at` to ISO timestamp
8. Find next pending command
9. If next pending exists: mark it `active`, write queue atomically, call `typeCommandIntoTmuxSession(sessionName, nextCommand.command)`, return `{ action: 'advanced', command: nextCommand.command }`
10. If no next pending (queue complete): write final queue state atomically, return `{ action: 'queue-complete', summary: buildQueueCompleteSummary(queueData) }` — the caller (event handler) uses this to wake the agent

**`buildQueueCompleteSummary(queueData)` (internal helper):**
Returns a JSON-serializable object matching CONTEXT.md queue-complete payload:
```json
{
  "event": "queue-complete",
  "summary": "N/N commands completed",
  "commands": [ { id, command, status, result, completed_at } ... ]
}
```

**Function 2: `cancelQueueForSession(sessionName)`**

1. Guard: return `false` if no queue file exists
2. Read the queue file
3. Rename queue file to `queue-{sessionName}.stale.json` (use `renameSync`)
4. Return object: `{ cancelled: true, completedCount, totalCount, remainingCommands }` — the caller uses this to build the cancellation notification for the agent

**Function 3: `cleanupStaleQueueForSession(sessionName)`**

1. Guard: return `false` if no queue file exists
2. Rename queue file to `queue-{sessionName}.stale.json`
3. Return `true`

**Imports:** `typeCommandIntoTmuxSession` from `./tui-common.mjs`, `appendJsonlEntry` from `./logger.mjs`, `SKILL_ROOT` from `./paths.mjs`.

**Then update `lib/index.mjs`:**
Add re-exports for the new modules:
```javascript
export { typeCommandIntoTmuxSession } from './tui-common.mjs';
export { processQueueForHook, cancelQueueForSession, cleanupStaleQueueForSession } from './queue-processor.mjs';
```
  </action>
  <verify>Run `node --check lib/queue-processor.mjs && node --check lib/index.mjs && node -e "import('./lib/index.mjs').then(m => { const names = Object.keys(m); console.log(names.length + ' exports: ' + names.join(', ')); })"` — must show 9 exports (5 existing + 4 new) with no errors.</verify>
  <done>lib/queue-processor.mjs exports processQueueForHook, cancelQueueForSession, cleanupStaleQueueForSession. lib/index.mjs re-exports all 9 functions from a single import path. `node -e "import('./lib/index.mjs')"` succeeds.</done>
</task>

</tasks>

<verification>
1. `node --check lib/tui-common.mjs` exits 0
2. `node --check lib/queue-processor.mjs` exits 0
3. `node --check lib/index.mjs` exits 0
4. `node -e "import('./lib/index.mjs').then(m => console.log(Object.keys(m).join(', ')))"` lists all 9 exports
5. Both new modules follow existing patterns: JSDoc, guard clauses, self-explanatory naming, no abbreviations
6. queue-processor uses atomic writes (tmp + rename) per CONTEXT.md
7. tui-common uses execFileSync with argument arrays per Phase 01.1 pattern
</verification>

<success_criteria>
- lib/tui-common.mjs exists and exports typeCommandIntoTmuxSession
- lib/queue-processor.mjs exists and exports processQueueForHook, cancelQueueForSession, cleanupStaleQueueForSession
- lib/index.mjs re-exports all 9 functions
- All three files pass `node --check`
- No new external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-stop-event-full-stack/03-01-SUMMARY.md`
</output>
