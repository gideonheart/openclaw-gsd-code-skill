---
phase: 01-additive-changes
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - scripts/session-end-hook.sh
  - scripts/pre-compact-hook.sh
autonomous: true
requirements:
  - HOOK-03
  - HOOK-09
  - HOOK-10

must_haves:
  truths:
    - "session-end-hook.sh notifies OpenClaw immediately when a managed Claude Code session terminates"
    - "session-end-hook.sh sends a minimal wake message with session identity and trigger type 'session_end' (no pane capture needed)"
    - "pre-compact-hook.sh captures pane state before context compaction and sends wake message with trigger type 'pre_compact'"
    - "Both hook scripts exit cleanly in under 5ms for non-managed sessions (no $TMUX or no registry match)"
    - "Both hook scripts share common guard patterns (stdin consumption, $TMUX check, registry lookup)"
  artifacts:
    - path: "scripts/session-end-hook.sh"
      provides: "SessionEnd hook notifying OpenClaw on session termination"
      min_lines: 40
    - path: "scripts/pre-compact-hook.sh"
      provides: "PreCompact hook capturing state before context compaction"
      min_lines: 60
  key_links:
    - from: "scripts/session-end-hook.sh"
      to: "config/recovery-registry.json"
      via: "jq lookup of agent by tmux_session_name"
      pattern: "jq.*select.*tmux_session_name"
    - from: "scripts/session-end-hook.sh"
      to: "openclaw agent"
      via: "Termination notification via openclaw agent --session-id"
      pattern: "openclaw agent.*--session-id"
    - from: "scripts/pre-compact-hook.sh"
      to: "config/recovery-registry.json"
      via: "jq lookup and three-tier fallback for pane capture depth"
      pattern: "hook_settings.*pane_capture_lines"
---

<objective>
Create the two session lifecycle hook scripts: session-end-hook.sh (fires when Claude Code session terminates) and pre-compact-hook.sh (fires before context compaction). These are lighter than the wake-message hooks -- session-end sends a minimal notification without pane capture, and pre-compact captures current state before context is compacted.

Purpose: session-end-hook enables faster session recovery by notifying OpenClaw immediately on termination (instead of waiting for the recovery daemon's polling interval). pre-compact-hook gives OpenClaw visibility into compaction events for monitoring and potential state preservation.

Output: Two executable bash scripts in scripts/ directory.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-additive-changes/01-RESEARCH.md
@.planning/phases/01-additive-changes/01-01-SUMMARY.md
@config/recovery-registry.json
@config/recovery-registry.example.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session-end-hook.sh for immediate session termination notification</name>
  <files>scripts/session-end-hook.sh</files>
  <action>
Create scripts/session-end-hook.sh as an executable bash script. This hook fires when a Claude Code session terminates (SessionEnd event). It sends a minimal notification to OpenClaw for faster recovery detection.

**Script structure (in order):**

1. **Shebang and pipefail:** `#!/usr/bin/env bash` and `set -euo pipefail`

2. **Consume stdin immediately:** `STDIN_JSON=$(cat)` -- same pattern as all hook scripts to prevent pipe blocking.

3. **Guard: $TMUX environment check:** `[ -z "${TMUX:-}" ] && exit 0`. Non-tmux sessions exit immediately.

4. **Extract tmux session name:** `SESSION_NAME=$(tmux display-message -p '#S' 2>/dev/null || echo "")`. Exit 0 if empty.

5. **Registry lookup:**
   - Determine script directory and registry path (same pattern as stop-hook.sh)
   - Exit 0 if registry file doesn't exist
   - Query agent data with jq to find agent matching session name
   - Exit 0 if no matching agent (non-managed session)
   - Extract `AGENT_ID` and `OPENCLAW_SESSION_ID`

6. **Build minimal wake message (HOOK-09):**
   This message is intentionally minimal -- no pane capture (session is ending, pane may be gone), no state detection, no context pressure. Just identity and trigger:
   ```
   [SESSION IDENTITY]
   agent_id: {AGENT_ID}
   tmux_session_name: {SESSION_NAME}
   timestamp: {ISO 8601 UTC}

   [TRIGGER]
   type: session_end

   [STATE HINT]
   state: terminated
   ```

   No [PANE CONTENT], [CONTEXT PRESSURE], or [AVAILABLE ACTIONS] sections -- the session is ending, these are meaningless.

7. **Deliver notification (always async):**
   SessionEnd is always async -- there's no point in bidirectional mode since the session is terminating. Send in background: `openclaw agent --session-id "$OPENCLAW_SESSION_ID" --message "$WAKE_MESSAGE" >/dev/null 2>&1 &`
   Exit 0.

**Key difference from stop-hook.sh:** No stop_hook_active check (SessionEnd doesn't cause loops), no pane capture, no state detection, no context pressure, no available actions, always async. This is the lightest hook script.

Make executable: `chmod +x scripts/session-end-hook.sh`
  </action>
  <verify>
Run: `bash -n scripts/session-end-hook.sh` to verify no syntax errors.
Run: `head -2 scripts/session-end-hook.sh` to verify shebang and pipefail.
Run: `grep 'STDIN_JSON=\$(cat)' scripts/session-end-hook.sh` to verify stdin consumption.
Run: `grep 'TMUX' scripts/session-end-hook.sh` to verify tmux guard.
Run: `grep 'session_end' scripts/session-end-hook.sh` to verify trigger type.
Run: `grep 'terminated' scripts/session-end-hook.sh` to verify state hint.
Run: `grep -c 'capture-pane' scripts/session-end-hook.sh` to verify NO pane capture (should return 0).
Run: `grep 'openclaw agent' scripts/session-end-hook.sh` to verify wake delivery.
Run: `test -x scripts/session-end-hook.sh && echo "executable"` to verify executable bit.
  </verify>
  <done>
session-end-hook.sh exists, is executable, sends minimal wake message (session identity + trigger type session_end + state terminated) to OpenClaw on session termination. No pane capture, no context pressure, always async. Shares common guards (stdin consumption, $TMUX check, registry lookup) with other hook scripts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pre-compact-hook.sh for state capture before context compaction</name>
  <files>scripts/pre-compact-hook.sh</files>
  <action>
Create scripts/pre-compact-hook.sh as an executable bash script. This hook fires before Claude Code compacts its context window (PreCompact event). It captures the current pane state so OpenClaw has visibility into what was happening before compaction.

**Script structure (in order):**

1. **Shebang and pipefail:** `#!/usr/bin/env bash` and `set -euo pipefail`

2. **Consume stdin immediately:** `STDIN_JSON=$(cat)` -- same pattern as all hook scripts.

3. **Guard: $TMUX environment check:** `[ -z "${TMUX:-}" ] && exit 0`.

4. **Extract tmux session name:** `SESSION_NAME=$(tmux display-message -p '#S' 2>/dev/null || echo "")`. Exit 0 if empty.

5. **Registry lookup:**
   - Same pattern as other hook scripts (script dir, registry path, jq query)
   - Exit 0 if no registry or no matching agent

6. **Extract hook_settings with three-tier fallback:**
   - Read global hook_settings from registry
   - Extract `PANE_CAPTURE_LINES` with fallback: per-agent > global > 100
   - Extract `CONTEXT_PRESSURE_THRESHOLD` with fallback: per-agent > global > 50
   - Extract `HOOK_MODE` with fallback: per-agent > global > "async"

7. **Capture pane content:** Same as stop-hook.sh using configurable `PANE_CAPTURE_LINES`.

8. **Extract context pressure:** Same pattern as stop-hook.sh (last 5 lines, grep percentage, threshold comparison).

9. **Build structured wake message (HOOK-10):**
   Similar to stop-hook.sh but with trigger type `pre_compact`:
   ```
   [SESSION IDENTITY]
   agent_id: {AGENT_ID}
   tmux_session_name: {SESSION_NAME}
   timestamp: {ISO 8601 UTC}

   [TRIGGER]
   type: pre_compact

   [STATE HINT]
   state: {STATE}

   [PANE CONTENT]
   {PANE_CONTENT}

   [CONTEXT PRESSURE]
   {CONTEXT_PRESSURE}

   [AVAILABLE ACTIONS]
   menu-driver.sh {SESSION_NAME} choose <n>
   menu-driver.sh {SESSION_NAME} type <text>
   menu-driver.sh {SESSION_NAME} clear_then <command>
   menu-driver.sh {SESSION_NAME} enter
   menu-driver.sh {SESSION_NAME} esc
   menu-driver.sh {SESSION_NAME} submit
   menu-driver.sh {SESSION_NAME} snapshot
   ```

10. **Hybrid mode delivery:**
    Same as stop-hook.sh -- check `HOOK_MODE` and use bidirectional or async accordingly. Pre-compact hook supports bidirectional mode because an OpenClaw agent might want to inject instructions before compaction happens (e.g., "save current task state").

Make executable: `chmod +x scripts/pre-compact-hook.sh`

**Key difference from stop-hook.sh:** No stop_hook_active check (PreCompact doesn't cause loops), trigger type is `pre_compact`. Otherwise follows the full wake message pattern including pane capture, state detection, context pressure, and hybrid mode.
  </action>
  <verify>
Run: `bash -n scripts/pre-compact-hook.sh` to verify no syntax errors.
Run: `head -2 scripts/pre-compact-hook.sh` to verify shebang and pipefail.
Run: `grep 'STDIN_JSON=\$(cat)' scripts/pre-compact-hook.sh` to verify stdin consumption.
Run: `grep 'TMUX' scripts/pre-compact-hook.sh` to verify tmux guard.
Run: `grep 'pre_compact' scripts/pre-compact-hook.sh` to verify trigger type.
Run: `grep 'capture-pane' scripts/pre-compact-hook.sh` to verify pane capture IS present.
Run: `grep 'CONTEXT PRESSURE' scripts/pre-compact-hook.sh` to verify context pressure section.
Run: `grep 'hook_mode.*bidirectional' scripts/pre-compact-hook.sh` to verify hybrid mode support.
Run: `grep 'openclaw agent' scripts/pre-compact-hook.sh` to verify wake delivery.
Run: `test -x scripts/pre-compact-hook.sh && echo "executable"` to verify executable bit.
  </verify>
  <done>
pre-compact-hook.sh exists, is executable, captures full pane state before context compaction with trigger type pre_compact. Includes pane content, state detection, context pressure with warning levels, all available actions, and supports hybrid mode. Shares common guards with other hook scripts.
  </done>
</task>

</tasks>

<verification>
1. Both scripts pass `bash -n` syntax check
2. Both scripts are executable (`test -x`)
3. Both scripts consume stdin immediately (`STDIN_JSON=$(cat)`)
4. Both scripts have $TMUX fast-path exit
5. session-end-hook.sh does NOT capture pane content (minimal message)
6. pre-compact-hook.sh DOES capture pane content with configurable depth
7. session-end-hook.sh trigger type is session_end
8. pre-compact-hook.sh trigger type is pre_compact
9. Both use jq for registry lookup (no Python)
10. pre-compact-hook.sh supports hybrid mode; session-end-hook.sh is always async
</verification>

<success_criteria>
- Two hook scripts exist in scripts/: session-end-hook.sh, pre-compact-hook.sh
- Both pass bash syntax validation and are executable
- session-end-hook.sh sends minimal notification (identity + trigger only, no pane capture)
- pre-compact-hook.sh captures full state (pane content, context pressure, state hint) before compaction
- Both share common guard patterns (stdin, $TMUX, registry)
- No Python used anywhere
- All Phase 1 hook scripts (5 total across Plans 02 and 03) are now created
</success_criteria>

<output>
After completion, create `.planning/phases/01-additive-changes/01-03-SUMMARY.md`
</output>
