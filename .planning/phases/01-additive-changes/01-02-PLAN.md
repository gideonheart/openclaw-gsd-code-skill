---
phase: 01-additive-changes
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - scripts/stop-hook.sh
  - scripts/notification-idle-hook.sh
  - scripts/notification-permission-hook.sh
autonomous: true
requirements:
  - HOOK-01
  - HOOK-02
  - HOOK-03
  - HOOK-04
  - HOOK-05
  - HOOK-06
  - HOOK-07
  - HOOK-08
  - HOOK-11
  - WAKE-01
  - WAKE-02
  - WAKE-03
  - WAKE-04
  - WAKE-05
  - WAKE-06

must_haves:
  truths:
    - "stop-hook.sh consumes stdin immediately, checks stop_hook_active, validates $TMUX, looks up agent in registry, captures pane content, detects state, extracts context pressure, builds structured wake message, and sends via async or bidirectional mode"
    - "notification-idle-hook.sh fires on idle_prompt events with trigger type 'idle_prompt' and same wake message structure as stop-hook"
    - "notification-permission-hook.sh fires on permission_prompt events with trigger type 'permission_prompt' and same wake message structure as stop-hook"
    - "All three hook scripts exit cleanly in under 5ms for non-managed sessions (no $TMUX or no registry match)"
    - "All three hook scripts support hybrid mode: async by default, bidirectional per-agent via hook_settings.hook_mode"
    - "Wake messages contain all required sections: SESSION IDENTITY, TRIGGER, STATE HINT, PANE CONTENT, CONTEXT PRESSURE, AVAILABLE ACTIONS"
    - "Context pressure shows percentage with warning level: OK below threshold, WARNING at threshold, CRITICAL at 80%+"
    - "Stop hook has stop_hook_active infinite loop guard that exits immediately when field is true in stdin JSON"
  artifacts:
    - path: "scripts/stop-hook.sh"
      provides: "Stop hook script for Claude Code response completion events"
      min_lines: 80
    - path: "scripts/notification-idle-hook.sh"
      provides: "Notification hook for idle_prompt events"
      min_lines: 60
    - path: "scripts/notification-permission-hook.sh"
      provides: "Notification hook for permission_prompt events"
      min_lines: 60
  key_links:
    - from: "scripts/stop-hook.sh"
      to: "config/recovery-registry.json"
      via: "jq lookup of agent by tmux_session_name"
      pattern: "jq.*select.*tmux_session_name"
    - from: "scripts/stop-hook.sh"
      to: "openclaw agent"
      via: "Wake message delivery via openclaw agent --session-id"
      pattern: "openclaw agent.*--session-id"
    - from: "scripts/stop-hook.sh"
      to: "config/recovery-registry.json"
      via: "Three-tier fallback for hook_settings fields"
      pattern: "hook_settings.*pane_capture_lines.*//.*global"
---

<objective>
Create the three wake-message-sending hook scripts: stop-hook.sh (fires on Claude Code response completion), notification-idle-hook.sh (fires when Claude waits for input), and notification-permission-hook.sh (fires on permission dialogs). All three share the same guard patterns and structured wake message format but differ in trigger type.

Purpose: These scripts are the core event-driven mechanism replacing polling. When registered in settings.json (Phase 2), they will notify OpenClaw agents instantly when Claude Code sessions change state, enabling intelligent autonomous decisions.

Output: Three executable bash scripts in scripts/ directory, all following the hook script pattern from research.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-additive-changes/01-RESEARCH.md
@.planning/phases/01-additive-changes/01-01-SUMMARY.md
@config/recovery-registry.json
@config/recovery-registry.example.json
@scripts/menu-driver.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stop-hook.sh with full guard chain, wake message, and hybrid mode</name>
  <files>scripts/stop-hook.sh</files>
  <action>
Create scripts/stop-hook.sh as an executable bash script. This is the primary hook script that fires when Claude Code finishes responding. It must follow the exact pattern from research with all safety guards.

**Script structure (in order):**

1. **Shebang and pipefail:** `#!/usr/bin/env bash` and `set -euo pipefail`

2. **Consume stdin immediately (HOOK-05):** `STDIN_JSON=$(cat)` -- must be the very first logic line to prevent pipe blocking. This is critical because Claude Code pipes JSON to hook stdin.

3. **Guard: stop_hook_active check (HOOK-04):** Parse `stop_hook_active` from stdin JSON using `echo "$STDIN_JSON" | jq -r '.stop_hook_active // false'`. If "true", exit 0 immediately. This prevents infinite loops where the hook's own wake message triggers another stop event.

4. **Guard: $TMUX environment check (HOOK-03):** `[ -z "${TMUX:-}" ] && exit 0`. Non-tmux Claude Code sessions (e.g., direct terminal use) must exit instantly with no side effects.

5. **Extract tmux session name:** `SESSION_NAME=$(tmux display-message -p '#S' 2>/dev/null || echo "")`. Exit 0 if empty.

6. **Registry lookup (HOOK-01, HOOK-02):**
   - Determine script directory and registry path: `SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"` then `REGISTRY_PATH="${SCRIPT_DIR}/../config/recovery-registry.json"`
   - Exit 0 if registry file doesn't exist
   - Query agent data with jq: select agent where `.tmux_session_name == $session`, extract `{agent_id, openclaw_session_id, hook_settings}`
   - Exit 0 if no matching agent found (non-managed session)

7. **Extract hook_settings with three-tier fallback (HOOK-11, CONFIG-04):**
   - Read global hook_settings: `GLOBAL_SETTINGS=$(jq -r '.hook_settings // {}' "$REGISTRY_PATH")`
   - Extract each field with fallback chain using `--argjson global "$GLOBAL_SETTINGS"`:
     - `PANE_CAPTURE_LINES`: per-agent > global > hardcoded 100
     - `CONTEXT_PRESSURE_THRESHOLD`: per-agent > global > hardcoded 50
     - `HOOK_MODE`: per-agent > global > hardcoded "async"

8. **Capture pane content (HOOK-02):** `PANE_CONTENT=$(tmux capture-pane -pt "${SESSION_NAME}:0.0" -S "-${PANE_CAPTURE_LINES}" 2>/dev/null || echo "")`

9. **Detect state via pattern matching (WAKE-03):**
   - Default: `STATE="working"`
   - Check patterns in order (first match wins):
     - `grep -Eiq 'Enter to select|numbered.*option'` -> `STATE="menu"`
     - `grep -Eiq 'permission|allow|dangerous'` -> `STATE="permission_prompt"`
     - `grep -Eiq 'What can I help|waiting for'` -> `STATE="idle"`
     - `grep -Ei 'error|failed|exception' | grep -v 'error handling'` -> `STATE="error"`
   - Use `echo "$PANE_CONTENT" | ...` for each check, with `2>/dev/null || true` to suppress errors

10. **Extract context pressure (HOOK-06, WAKE-06):**
    - Extract percentage from last 5 lines: `echo "$PANE_CONTENT" | tail -5 | grep -oE '[0-9]{1,3}%' | tail -1 | tr -d '%'`
    - Determine warning level against threshold:
      - >= 80: `CRITICAL`
      - >= threshold: `WARNING`
      - < threshold: `OK`
      - Not found: `unknown`
    - Format: `CONTEXT_PRESSURE="${PERCENTAGE}% [WARNING]"` or `CONTEXT_PRESSURE="unknown"`

11. **Build structured wake message (WAKE-01, WAKE-02, WAKE-03, WAKE-04, WAKE-05):**
    Plain text with section markers:
    ```
    [SESSION IDENTITY]
    agent_id: {AGENT_ID}
    tmux_session_name: {SESSION_NAME}
    timestamp: {ISO 8601 UTC}

    [TRIGGER]
    type: response_complete

    [STATE HINT]
    state: {STATE}

    [PANE CONTENT]
    {PANE_CONTENT}

    [CONTEXT PRESSURE]
    {CONTEXT_PRESSURE}

    [AVAILABLE ACTIONS]
    menu-driver.sh {SESSION_NAME} choose <n>
    menu-driver.sh {SESSION_NAME} type <text>
    menu-driver.sh {SESSION_NAME} clear_then <command>
    menu-driver.sh {SESSION_NAME} enter
    menu-driver.sh {SESSION_NAME} esc
    menu-driver.sh {SESSION_NAME} submit
    menu-driver.sh {SESSION_NAME} snapshot
    ```
    Include timestamp as ISO 8601 UTC (`date -u +'%Y-%m-%dT%H:%M:%SZ'`) for operational value.
    Always list all available actions regardless of state (WAKE-05) -- OpenClaw agent decides relevance.

12. **Hybrid mode delivery (HOOK-11):**
    - If `HOOK_MODE` is "bidirectional": Run `openclaw agent --session-id "$OPENCLAW_SESSION_ID" --message "$WAKE_MESSAGE" --json` synchronously. Parse response for `decision` field. If `decision: "block"` with `reason`, output `{"decision": "block", "reason": "..."}` to stdout (Claude Code will use this). Otherwise exit 0.
    - If `HOOK_MODE` is "async" (default): Run `openclaw agent --session-id "$OPENCLAW_SESSION_ID" --message "$WAKE_MESSAGE" >/dev/null 2>&1 &` in background, exit 0 immediately.

Make the script executable: `chmod +x scripts/stop-hook.sh`

**Important implementation notes:**
- Use `jq -r` (raw output) for all string extractions to avoid quoted strings
- All jq calls must have `2>/dev/null || echo ""` fallback to prevent crashes on malformed data
- The script must NEVER fail with a non-zero exit code for normal operations (guards exit 0, not exit 1)
- No Python anywhere -- jq only for all JSON operations
  </action>
  <verify>
Run: `bash -n scripts/stop-hook.sh` to verify no syntax errors.
Run: `head -2 scripts/stop-hook.sh` to verify shebang and pipefail.
Run: `grep -c 'exit 0' scripts/stop-hook.sh` to verify multiple fast-path exits exist.
Run: `grep 'STDIN_JSON=\$(cat)' scripts/stop-hook.sh` to verify stdin consumption is present.
Run: `grep 'stop_hook_active' scripts/stop-hook.sh` to verify infinite loop guard.
Run: `grep 'TMUX' scripts/stop-hook.sh` to verify tmux environment check.
Run: `grep 'openclaw agent' scripts/stop-hook.sh` to verify wake message delivery.
Run: `grep 'hook_mode.*bidirectional' scripts/stop-hook.sh` to verify hybrid mode support.
Run: `grep '\[SESSION IDENTITY\]' scripts/stop-hook.sh` to verify structured wake message format.
Run: `grep '\[CONTEXT PRESSURE\]' scripts/stop-hook.sh` to verify context pressure section.
Run: `test -x scripts/stop-hook.sh && echo "executable"` to verify executable bit.
  </verify>
  <done>
stop-hook.sh exists and is executable with all required guards (stdin consumption, stop_hook_active, $TMUX, registry lookup), pane capture with configurable depth, state detection via pattern matching, context pressure extraction with threshold-based warning levels, structured wake message with all 6 sections, and hybrid mode support (async default, bidirectional per-agent). No Python dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notification-idle-hook.sh and notification-permission-hook.sh</name>
  <files>scripts/notification-idle-hook.sh, scripts/notification-permission-hook.sh</files>
  <action>
Create two notification hook scripts that share the same structure as stop-hook.sh but with different trigger types. These scripts handle Notification events from Claude Code.

**notification-idle-hook.sh (HOOK-07):**

This hook fires when Claude Code is waiting for user input (idle_prompt notification). It follows the EXACT same structure as stop-hook.sh with these differences:
- **No stop_hook_active check** -- idle_prompt notifications don't cause infinite loops (they fire once when idle, and only a user message or hook response triggers Claude to continue)
- **Trigger type:** `type: idle_prompt` instead of `type: response_complete`
- Everything else identical: stdin consumption, $TMUX guard, session name extraction, registry lookup, three-tier hook_settings fallback, pane capture, state detection, context pressure, structured wake message, hybrid mode

Since this script shares ~90% of the logic with stop-hook.sh, implement it as a standalone script (NOT sourcing stop-hook.sh -- SRP per locked decision). Copy the pattern and adjust the trigger type and remove the stop_hook_active guard.

**notification-permission-hook.sh (HOOK-08):**

This hook fires on permission dialogs (future-proofing since --dangerously-skip-permissions is used). Same structure as notification-idle-hook.sh with:
- **Trigger type:** `type: permission_prompt` instead of `type: idle_prompt`
- Everything else identical to notification-idle-hook.sh

Both scripts should:
- Start with `#!/usr/bin/env bash` and `set -euo pipefail`
- Consume stdin immediately: `STDIN_JSON=$(cat)`
- Have the $TMUX guard for fast exit on non-tmux sessions
- Use the same registry lookup and three-tier fallback pattern
- Build the same structured wake message format (all 6 sections)
- Support hybrid mode (async/bidirectional)
- Be made executable with `chmod +x`

**DRY consideration:** While these scripts duplicate logic, they are separate per SRP (locked decision). Each script is self-contained and independently maintainable. A shared library/source pattern was explicitly not chosen. The duplication is intentional.
  </action>
  <verify>
Run: `bash -n scripts/notification-idle-hook.sh` to verify no syntax errors.
Run: `bash -n scripts/notification-permission-hook.sh` to verify no syntax errors.
Run: `grep 'idle_prompt' scripts/notification-idle-hook.sh` to verify trigger type.
Run: `grep 'permission_prompt' scripts/notification-permission-hook.sh` to verify trigger type.
Run: `grep -c 'stop_hook_active' scripts/notification-idle-hook.sh` to verify NO stop_hook_active check (should return 0).
Run: `grep -c 'stop_hook_active' scripts/notification-permission-hook.sh` to verify NO stop_hook_active check (should return 0).
Run: `grep 'STDIN_JSON=\$(cat)' scripts/notification-idle-hook.sh` to verify stdin consumption.
Run: `grep 'STDIN_JSON=\$(cat)' scripts/notification-permission-hook.sh` to verify stdin consumption.
Run: `grep 'TMUX' scripts/notification-idle-hook.sh` to verify tmux guard.
Run: `grep '\[SESSION IDENTITY\]' scripts/notification-idle-hook.sh` to verify wake message format.
Run: `grep 'openclaw agent' scripts/notification-idle-hook.sh` to verify wake delivery.
Run: `test -x scripts/notification-idle-hook.sh && echo "executable"` to verify executable bit.
Run: `test -x scripts/notification-permission-hook.sh && echo "executable"` to verify executable bit.
  </verify>
  <done>
notification-idle-hook.sh and notification-permission-hook.sh exist, are executable, follow the same guard and wake message pattern as stop-hook.sh, use correct trigger types (idle_prompt and permission_prompt respectively), have no stop_hook_active guard (not needed for notification hooks), and support hybrid mode. No Python dependencies.
  </done>
</task>

</tasks>

<verification>
1. All three scripts pass `bash -n` syntax check
2. All three scripts are executable (`test -x`)
3. stop-hook.sh has stop_hook_active guard; notification hooks do not
4. All three scripts consume stdin immediately (`STDIN_JSON=$(cat)`)
5. All three scripts have $TMUX fast-path exit
6. All three scripts use jq for registry lookup (no Python)
7. All three scripts build structured wake messages with all 6 sections
8. All three scripts support hybrid mode (async/bidirectional)
9. Each script has the correct trigger type (response_complete, idle_prompt, permission_prompt)
10. No Python used anywhere
</verification>

<success_criteria>
- Three hook scripts exist in scripts/ directory: stop-hook.sh, notification-idle-hook.sh, notification-permission-hook.sh
- All pass bash syntax validation
- All are executable
- All share common guard patterns (stdin, $TMUX, registry) but are standalone scripts (SRP)
- All build structured wake messages with session identity, trigger, state hint, pane content, context pressure, available actions
- All support three-tier hook_settings fallback via jq
- All support hybrid mode (async default, bidirectional per-agent)
- Stop hook has stop_hook_active infinite loop guard
</success_criteria>

<output>
After completion, create `.planning/phases/01-additive-changes/01-02-SUMMARY.md`
</output>
