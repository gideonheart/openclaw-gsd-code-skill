---
phase: 15-prompt-template-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/hook-utils.sh
autonomous: true
requirements:
  - PROMPT-01

must_haves:
  truths:
    - "load_hook_prompt() loads a template file from scripts/prompts/{name}.md and returns its content with placeholders substituted"
    - "When a template file is missing, load_hook_prompt() returns an empty string instead of crashing"
    - "Placeholders {SESSION_NAME}, {MENU_DRIVER_PATH}, and {SCRIPT_DIR} are replaced with caller-provided values"
  artifacts:
    - path: "lib/hook-utils.sh"
      provides: "load_hook_prompt() function"
      contains: "load_hook_prompt"
  key_links:
    - from: "lib/hook-utils.sh"
      to: "scripts/prompts/*.md"
      via: "file read with cat"
      pattern: "scripts/prompts/"
---

<objective>
Add load_hook_prompt() function to lib/hook-utils.sh that loads per-hook prompt template files from scripts/prompts/{name}.md, substitutes {SESSION_NAME}, {MENU_DRIVER_PATH}, and {SCRIPT_DIR} placeholders, and returns the rendered content.

Purpose: This function is the foundation for Phase 16's hook migration, where all 7 hooks will replace hardcoded [AVAILABLE ACTIONS] blocks with load_hook_prompt() calls that load hook-specific [ACTION REQUIRED] instructions from external template files.

Output: lib/hook-utils.sh extended with load_hook_prompt() function (function #10 in the shared library).
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/hook-utils.sh
@lib/hook-preamble.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add load_hook_prompt() function to lib/hook-utils.sh</name>
  <files>lib/hook-utils.sh</files>
  <action>
Add a new function `load_hook_prompt()` to the end of lib/hook-utils.sh, following the existing documentation block style (========== header, Arguments, Returns sections).

Function signature and behavior:
- Arguments (4 positional):
  $1 - template_name:     basename without extension (e.g., "response-complete", "ask-user-question")
  $2 - session_name:      tmux session name for {SESSION_NAME} substitution
  $3 - menu_driver_path:  full path to menu-driver.sh for {MENU_DRIVER_PATH} substitution
  $4 - script_directory:  full path to scripts/ directory for {SCRIPT_DIR} substitution

Implementation:
1. Resolve template path: Use the _GSD_SKILL_ROOT variable (set by hook-preamble.sh) to construct the path: "${_GSD_SKILL_ROOT}/scripts/prompts/${template_name}.md"
2. Check file existence: If template file does not exist, print empty string via `printf ''` and return 0 (graceful fallback, never crash)
3. Read file content: Use `cat` to read the template file content
4. Substitute placeholders using bash parameter expansion (sed):
   - {SESSION_NAME} -> $session_name
   - {MENU_DRIVER_PATH} -> $menu_driver_path
   - {SCRIPT_DIR} -> $script_directory
5. Print substituted content via printf '%s'
6. Return 0 always

Use `sed` for placeholder substitution with pipe chain:
```
sed "s|{SESSION_NAME}|${session_name}|g" |
sed "s|{MENU_DRIVER_PATH}|${menu_driver_path}|g" |
sed "s|{SCRIPT_DIR}|${script_directory}|g"
```

Use pipe delimiter `|` in sed (not `/`) because paths contain forward slashes.

Error handling: Wrap the entire cat+sed pipeline in a subshell with `2>/dev/null || printf ''` to ensure any read/parse failure returns empty string, never crashes.

Place the function AFTER detect_session_state() (the last function currently in the file) to maintain the logical grouping: lookup > extraction > formatting > logging > delivery > settings > state > prompt loading.
  </action>
  <verify>
Verify function exists and is syntactically valid:
```bash
bash -n lib/hook-utils.sh && echo "syntax ok"
grep -c 'load_hook_prompt' lib/hook-utils.sh
```

Test graceful fallback with missing template:
```bash
source lib/hook-preamble.sh 2>/dev/null || true
_GSD_SKILL_ROOT="$(cd "$(dirname "lib/hook-utils.sh")/.." && pwd)"
source lib/hook-utils.sh
result=$(load_hook_prompt "nonexistent-template" "test-session" "/path/to/menu" "/path/to/scripts")
echo "result='${result}' (should be empty)"
[ -z "$result" ] && echo "PASS: graceful fallback" || echo "FAIL: non-empty on missing template"
```

Test placeholder substitution with a temporary template:
```bash
mkdir -p scripts/prompts
printf 'Session: {SESSION_NAME}\nDriver: {MENU_DRIVER_PATH}\nDir: {SCRIPT_DIR}\n' > scripts/prompts/test-template.md
result=$(load_hook_prompt "test-template" "gideon-main" "/home/forge/menu-driver.sh" "/home/forge/scripts")
echo "$result"
rm scripts/prompts/test-template.md
# Should show: Session: gideon-main, Driver: /home/forge/menu-driver.sh, Dir: /home/forge/scripts
```
  </verify>
  <done>
load_hook_prompt() function exists in lib/hook-utils.sh, loads template files from scripts/prompts/{name}.md, substitutes all 3 placeholders, returns empty string on missing template without crashing, and lib/hook-utils.sh passes bash -n syntax check.
  </done>
</task>

</tasks>

<verification>
1. `bash -n lib/hook-utils.sh` exits 0 (no syntax errors)
2. `grep -c 'load_hook_prompt' lib/hook-utils.sh` returns at least 2 (function name + declaration)
3. Calling load_hook_prompt() with a nonexistent template returns empty string (no crash)
4. Calling load_hook_prompt() with a test template correctly substitutes all 3 placeholders
</verification>

<success_criteria>
- load_hook_prompt() function added to lib/hook-utils.sh with full documentation block
- All 3 placeholders ({SESSION_NAME}, {MENU_DRIVER_PATH}, {SCRIPT_DIR}) substituted correctly
- Missing template file produces empty string return, never a crash or non-zero exit
- lib/hook-utils.sh passes syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/15-prompt-template-foundation/15-01-SUMMARY.md`
</output>
