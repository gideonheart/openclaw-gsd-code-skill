---
phase: 04-askuserquestion-lifecycle-full-stack
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ask-user-question.mjs
  - lib/index.mjs
autonomous: true
requirements:
  - ASK-01
  - ASK-03

must_haves:
  truths:
    - "formatQuestionsForAgent produces a readable markdown string with numbered options, question headers, multiSelect flags, and the 'How to answer' instruction block — matching the exact gateway message format from CONTEXT.md"
    - "saveQuestionMetadata writes an atomic JSON file at logs/queues/question-{session}.json with tool_use_id, saved_at, session, and questions array"
    - "readQuestionMetadata returns the parsed JSON object or null if file does not exist"
    - "savePendingAnswer writes an atomic JSON file at logs/queues/pending-answer-{session}.json with tool_use_id, saved_at, session, answers, and action fields"
    - "compareAnswerWithIntent returns { matched: true } when pending answer aligns with tool_response.answers, and { matched: false, reason } with specific mismatch details otherwise"
    - "lib/index.mjs re-exports all 8 new functions from ask-user-question.mjs"
  artifacts:
    - path: "lib/ask-user-question.mjs"
      provides: "All AskUserQuestion domain logic — 8 exported functions"
      exports:
        - formatQuestionsForAgent
        - saveQuestionMetadata
        - readQuestionMetadata
        - deleteQuestionMetadata
        - savePendingAnswer
        - readPendingAnswer
        - deletePendingAnswer
        - compareAnswerWithIntent
    - path: "lib/index.mjs"
      provides: "Updated re-export entry point including ask-user-question.mjs functions"
  key_links:
    - from: "lib/ask-user-question.mjs"
      to: "lib/paths.mjs"
      via: "SKILL_ROOT import for QUEUES_DIRECTORY constant"
      pattern: "import.*SKILL_ROOT.*from.*paths\\.mjs"
    - from: "lib/ask-user-question.mjs"
      to: "lib/logger.mjs"
      via: "appendJsonlEntry for all file operations"
      pattern: "import.*appendJsonlEntry.*from.*logger\\.mjs"
    - from: "lib/index.mjs"
      to: "lib/ask-user-question.mjs"
      via: "named re-exports"
      pattern: "export.*from.*ask-user-question\\.mjs"
---

<objective>
Build the shared AskUserQuestion domain library that all Phase 4 handlers and drivers import from.

Purpose: `lib/ask-user-question.mjs` is the single-source-of-truth for all AskUserQuestion domain knowledge — question metadata file I/O, pending answer file I/O, agent prompt formatting, and answer verification comparison. Without this module, the handler and driver plans would duplicate domain logic.

Output: `lib/ask-user-question.mjs` with 8 exported functions + updated `lib/index.mjs` re-exports.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-askuserquestion-lifecycle-full-stack/04-CONTEXT.md
@.planning/phases/04-askuserquestion-lifecycle-full-stack/04-RESEARCH.md
@lib/paths.mjs
@lib/logger.mjs
@lib/queue-processor.mjs
@lib/index.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/ask-user-question.mjs with all 8 domain functions</name>
  <files>lib/ask-user-question.mjs</files>
  <action>
Create `lib/ask-user-question.mjs` — the shared AskUserQuestion domain module. Follow the exact same patterns as `lib/queue-processor.mjs`: import SKILL_ROOT from `./paths.mjs`, derive QUEUES_DIRECTORY as `resolve(SKILL_ROOT, 'logs', 'queues')`, use atomic tmp+rename writes.

**File I/O constants and helpers (internal, not exported):**
- `QUEUES_DIRECTORY` = `resolve(SKILL_ROOT, 'logs', 'queues')` — same as queue-processor.mjs
- `resolveQuestionFilePath(sessionName)` returns `resolve(QUEUES_DIRECTORY, 'question-' + sessionName + '.json')` — internal helper
- `resolvePendingAnswerFilePath(sessionName)` returns `resolve(QUEUES_DIRECTORY, 'pending-answer-' + sessionName + '.json')` — internal helper
- `writeFileAtomically(filePath, data)` — writes JSON.stringify(data, null, 2) to `.tmp` path then `renameSync` to final path. mkdirSync(dirname(filePath), { recursive: true }) for safety. Same pattern as `writeQueueFileAtomically` in queue-processor.mjs.

**Exported functions (8 total):**

1. `formatQuestionsForAgent(toolInput, sessionName)` — Takes the `tool_input` object from PreToolUse payload. Returns a markdown string matching the exact gateway message format from CONTEXT.md:
   ```
   ## AskUserQuestion from Claude Code

   **Session:** {sessionName}

   ### Question 1: {header} ({multiSelect ? 'multi-select' : 'single-select'})
     0. {label} — {description}
     1. {label} — {description}
     ...

   ## How to answer
   Read each question. Read the option descriptions. Cross-reference with your project context
   (STATE.md, ROADMAP.md, CONTEXT.md — already in your conversation).

   For EVERY question, decide:
   - Does one option clearly align with project direction? -> select it
   - Is an option close but missing nuance? -> use "Type something" to give the right answer
     with your reasoning
   - Does Claude Code's recommended option (first) actually make sense? -> verify against
     ROADMAP.md and STATE.md before accepting. Claude Code can hallucinate.
   - Is the question itself wrong (contradicts project state, wrong phase)? -> use "Chat about
     this" to redirect Claude Code
   - For multi-select: which items are relevant to current phase? Select only what matters.

   Answer format per question:
     Pick option:    { "action": "select", "optionIndex": N }
     Type answer:    { "action": "type", "text": "your reasoned answer" }
     Multi-select:   { "action": "multi-select", "selectedIndices": [0, 2] }
     Redirect:       { "action": "chat", "text": "explanation of what's wrong" }

   Call:
     node {SKILL_ROOT}/bin/tui-driver-ask.mjs --session {sessionName} '<json array>'
   ```
   Use SKILL_ROOT from paths.mjs for the absolute path in the call instruction. Iterate `toolInput.questions` array. Each question has: `question` (string), `header` (string, optional), `multiSelect` (boolean), `options` (array of `{ label, description }`). If `header` is missing, use `"Question {N}"` as fallback.

2. `saveQuestionMetadata(sessionName, toolInput, toolUseId)` — Writes atomic JSON to `question-{session}.json`:
   ```json
   {
     "tool_use_id": toolUseId,
     "saved_at": new Date().toISOString(),
     "session": sessionName,
     "questions": toolInput.questions
   }
   ```
   Log info-level entry via appendJsonlEntry on write. Use writeFileAtomically helper.

3. `readQuestionMetadata(sessionName)` — Reads and parses `question-{session}.json`. Returns parsed object or null if file does not exist. Wrap readFileSync in try/catch — catch ENOENT returns null, other errors rethrow.

4. `deleteQuestionMetadata(sessionName)` — Deletes `question-{session}.json` via unlinkSync. Silently ignores ENOENT (file already gone). Log debug-level entry.

5. `savePendingAnswer(sessionName, answers, action, toolUseId)` — Writes atomic JSON to `pending-answer-{session}.json`:
   ```json
   {
     "tool_use_id": toolUseId,
     "saved_at": new Date().toISOString(),
     "session": sessionName,
     "answers": answers,
     "action": action
   }
   ```
   Where `answers` is the agent's intended answers (e.g. `{ "0": "Option A" }`) and `action` is the action type string. Log info-level entry.

6. `readPendingAnswer(sessionName)` — Same pattern as readQuestionMetadata but for `pending-answer-{session}.json`. Returns parsed object or null.

7. `deletePendingAnswer(sessionName)` — Same pattern as deleteQuestionMetadata but for `pending-answer-{session}.json`.

8. `compareAnswerWithIntent(pendingAnswer, toolResponse, toolInput)` — Compares what the TUI driver intended with what Claude Code recorded. Returns `{ matched: true }` or `{ matched: false, reason: string }`.
   - `pendingAnswer` is the object from readPendingAnswer (has `answers`, `action`, `tool_use_id`)
   - `toolResponse` is the hookPayload.tool_response object (has `answers` as Record<string, string>)
   - `toolInput` is the hookPayload.tool_input (has `questions` array for label resolution)
   - For `action: "chat"`: always return `{ matched: true }` — chat breaks normal flow, skip verification (per CONTEXT.md)
   - For `action: "select"`: look up intended option label from `toolInput.questions[questionIndex].options[pendingAnswer.answers[questionIndex]].label`. Compare with the corresponding value in `toolResponse.answers`. Normalize: trim whitespace, case-insensitive.
   - For `action: "type"`: check that `toolResponse.answers` value contains the intended text (substring match after trim+lowercase). Typed text may appear with additional formatting.
   - For `action: "multi-select"`: verify ALL selected option labels appear in the response. Normalize same way.
   - **Key format flexibility:** `toolResponse.answers` keys could be string indices ("0", "1") OR question text. Try string index first; if not found, try matching by question text from `toolInput.questions[i].question`. Log which format was detected for debugging (per RESEARCH.md open question 1).
   - If `pendingAnswer.tool_use_id` does not match `toolResponse` context, log a warning but proceed (per RESEARCH.md Pitfall 4).

**Imports needed:** `writeFileSync`, `renameSync`, `readFileSync`, `unlinkSync`, `mkdirSync`, `existsSync` from `node:fs`; `resolve`, `dirname` from `node:path`; `SKILL_ROOT` from `./paths.mjs`; `appendJsonlEntry` from `./logger.mjs`.

**Style:** Follow existing lib patterns — JSDoc on all exported functions, guard clauses with early returns, self-explanatory variable names (no abbreviations per CLAUDE.md). Internal helpers are unexported functions in the same module.
  </action>
  <verify>
Run `node -e "import('./lib/ask-user-question.mjs').then(m => { const names = Object.keys(m); console.log('Exports:', names.length, names.sort().join(', ')); if (names.length !== 8) process.exit(1); })"` — must print 8 export names and exit 0.

Run `node -e "import('./lib/ask-user-question.mjs').then(m => { const result = m.formatQuestionsForAgent({ questions: [{ question: 'Test?', header: 'H', multiSelect: false, options: [{ label: 'A', description: 'desc' }] }] }, 'test-session'); console.log(result); if (!result.includes('AskUserQuestion from Claude Code')) process.exit(1); if (!result.includes('test-session')) process.exit(1); })"` — must include expected header and session name.

Run `node -e "import('./lib/ask-user-question.mjs').then(m => { const result = m.compareAnswerWithIntent({ answers: { '0': 'Option A' }, action: 'select', tool_use_id: 'x' }, { answers: { '0': 'Option A' } }, { questions: [{ question: 'Q?', options: [{ label: 'Option A' }] }] }); console.log(result); if (!result.matched) process.exit(1); })"` — must return matched: true for matching select.
  </verify>
  <done>lib/ask-user-question.mjs exports exactly 8 functions. formatQuestionsForAgent produces the CONTEXT.md gateway format. compareAnswerWithIntent correctly identifies matches and mismatches for all action types. All file I/O uses atomic tmp+rename pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Update lib/index.mjs to re-export ask-user-question.mjs functions</name>
  <files>lib/index.mjs</files>
  <action>
Add a re-export line to `lib/index.mjs` for all 8 functions from ask-user-question.mjs. Follow the existing pattern — one export statement per source module, alphabetically placed.

Add this line after the existing exports (maintain alphabetical order by module name — `ask-user-question.mjs` comes first):

```javascript
export { formatQuestionsForAgent, saveQuestionMetadata, readQuestionMetadata, deleteQuestionMetadata, savePendingAnswer, readPendingAnswer, deletePendingAnswer, compareAnswerWithIntent } from './ask-user-question.mjs';
```

Place it as the first export line (before agent-resolver.mjs) since `a` sorts before other letters. Update the file header comment to reflect the new count of exports.
  </action>
  <verify>
Run `node -e "import('./lib/index.mjs').then(m => { const names = Object.keys(m); console.log('Total exports:', names.length, names.sort().join(', ')); if (!names.includes('formatQuestionsForAgent')) process.exit(1); if (!names.includes('compareAnswerWithIntent')) process.exit(1); })"` — must include the 8 new exports alongside all existing ones.
  </verify>
  <done>lib/index.mjs re-exports all 8 ask-user-question.mjs functions. Total export count is previous count + 8. `node -e "import('./lib/index.mjs')"` succeeds without error.</done>
</task>

</tasks>

<verification>
1. `node -e "import('./lib/ask-user-question.mjs')"` — module loads without errors
2. `node -e "import('./lib/index.mjs')"` — unified entry point loads without errors
3. All 8 functions importable from both paths
4. formatQuestionsForAgent output matches CONTEXT.md gateway message format (markdown with numbered options, session name, How to answer block, CLI call instruction with absolute path)
5. File I/O functions write to correct paths under logs/queues/ using atomic tmp+rename
6. compareAnswerWithIntent handles select, type, multi-select, and chat action types
7. No new npm dependencies — pure Node.js built-ins
</verification>

<success_criteria>
- lib/ask-user-question.mjs exists with 8 exported functions and JSDoc documentation
- lib/index.mjs re-exports all 8 new functions
- Both modules load without error via `node -e "import(...)"`
- Domain logic correctly handles all 4 action types (select, type, multi-select, chat)
- Atomic file I/O follows existing queue-processor.mjs patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-askuserquestion-lifecycle-full-stack/04-01-SUMMARY.md`
</output>
