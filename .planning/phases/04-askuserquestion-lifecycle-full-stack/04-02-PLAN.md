---
phase: 04-askuserquestion-lifecycle-full-stack
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - events/pre_tool_use/event_pre_tool_use.mjs
  - events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs
  - events/pre_tool_use/ask_user_question/prompt_ask_user_question.md
  - bin/tui-driver-ask.mjs
autonomous: true
requirements:
  - ASK-01
  - ASK-02
  - TUI-03
  - TUI-04

must_haves:
  truths:
    - "PreToolUse router reads tool_name from hook payload and dispatches AskUserQuestion to the domain handler"
    - "PreToolUse handler saves question metadata to logs/queues/question-{session}.json before waking the agent"
    - "PreToolUse handler wakes OpenClaw agent via wakeAgentWithRetry with formatted questions and prompt instructions"
    - "prompt_ask_user_question.md instructs the agent to classify the question, cross-reference project context, and call tui-driver-ask.mjs"
    - "tui-driver-ask.mjs reads question metadata from file, saves pending answer before typing, and sends correct tmux keystrokes per action type"
    - "tui-driver-ask.mjs supports all 4 action types: select (Down + Enter), type (navigate to Type something + type text + Enter), multi-select (Down + Space toggles + Enter), chat (navigate to Chat about this + type text + Enter)"
  artifacts:
    - path: "events/pre_tool_use/event_pre_tool_use.mjs"
      provides: "PreToolUse router — readHookContext, dispatch by tool_name"
      min_lines: 25
    - path: "events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs"
      provides: "AskUserQuestion PreToolUse domain handler"
      exports:
        - handleAskUserQuestion
    - path: "events/pre_tool_use/ask_user_question/prompt_ask_user_question.md"
      provides: "Agent prompt for answering AskUserQuestion questions"
    - path: "bin/tui-driver-ask.mjs"
      provides: "AskUserQuestion TUI driver — reads question file, saves pending answer, types keystrokes"
      min_lines: 80
  key_links:
    - from: "events/pre_tool_use/event_pre_tool_use.mjs"
      to: "events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs"
      via: "dynamic import by tool_name match"
      pattern: "handleAskUserQuestion"
    - from: "events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs"
      to: "lib/ask-user-question.mjs"
      via: "formatQuestionsForAgent + saveQuestionMetadata imports"
      pattern: "import.*formatQuestionsForAgent.*saveQuestionMetadata"
    - from: "events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs"
      to: "lib/gateway.mjs"
      via: "wakeAgentWithRetry for fire-and-forget agent wake"
      pattern: "wakeAgentWithRetry"
    - from: "bin/tui-driver-ask.mjs"
      to: "lib/ask-user-question.mjs"
      via: "readQuestionMetadata + savePendingAnswer imports"
      pattern: "import.*readQuestionMetadata.*savePendingAnswer"
    - from: "bin/tui-driver-ask.mjs"
      to: "lib/tui-common.mjs"
      via: "sendKeysToTmux + sendSpecialKeyToTmux for tmux navigation (currently unexported — must export)"
      pattern: "sendKeysToTmux|sendSpecialKeyToTmux"
---

<objective>
Build the PreToolUse handler chain and AskUserQuestion TUI driver — the "question arrives, agent decides, TUI types answer" path.

Purpose: This plan delivers the input side of the AskUserQuestion lifecycle. When Claude Code presents a question, the PreToolUse router dispatches to the domain handler which saves question metadata and wakes the OpenClaw agent. The agent reads the formatted questions, makes a decision, and calls tui-driver-ask.mjs which navigates the TUI and types the answer. The verification side (PostToolUse) is Plan 03.

Output: 3 new files in events/pre_tool_use/ + 1 new file bin/tui-driver-ask.mjs. The agent can receive questions and answer them.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-askuserquestion-lifecycle-full-stack/04-CONTEXT.md
@.planning/phases/04-askuserquestion-lifecycle-full-stack/04-RESEARCH.md
@.planning/phases/04-askuserquestion-lifecycle-full-stack/04-01-SUMMARY.md
@events/stop/event_stop.mjs
@lib/hook-context.mjs
@lib/gateway.mjs
@lib/tui-common.mjs
@bin/tui-driver.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PreToolUse router and AskUserQuestion handler with prompt</name>
  <files>
    events/pre_tool_use/event_pre_tool_use.mjs
    events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs
    events/pre_tool_use/ask_user_question/prompt_ask_user_question.md
  </files>
  <action>
**IMPORTANT PREREQUISITE:** Before creating these files, `sendKeysToTmux` and `sendSpecialKeyToTmux` in `lib/tui-common.mjs` are currently unexported (private functions). The TUI driver in Task 2 needs them. Export both functions by adding the `export` keyword to their function declarations. This is a minimal change — just add `export` before `function sendKeysToTmux` and `export function sendSpecialKeyToTmux`. Also add re-exports in `lib/index.mjs`: `export { typeCommandIntoTmuxSession, sendKeysToTmux, sendSpecialKeyToTmux } from './tui-common.mjs';` (update the existing tui-common export line).

**File 1: events/pre_tool_use/event_pre_tool_use.mjs**

Router handler — follows the exact same structure as `events/stop/event_stop.mjs` but dispatches by `tool_name` instead of processing directly. This is the file registered in settings.json (one per hook event type).

```javascript
// Structure (not verbatim — use self-explanatory names, JSDoc, proper patterns):
import { readHookContext, appendJsonlEntry } from '../../lib/index.mjs';
import { handleAskUserQuestion } from './ask_user_question/handle_ask_user_question.mjs';

async function main() {
  const hookContext = readHookContext('event_pre_tool_use');
  if (!hookContext) process.exit(0);
  const { hookPayload, sessionName, resolvedAgent } = hookContext;

  const toolName = hookPayload.tool_name;

  if (toolName === 'AskUserQuestion') {
    await handleAskUserQuestion({ hookPayload, sessionName, resolvedAgent });
    process.exit(0);
  }

  // No handler for this tool — exit cleanly
  appendJsonlEntry({
    level: 'debug',
    source: 'event_pre_tool_use',
    message: `No handler for tool_name: ${toolName}`,
    session: sessionName,
  }, sessionName);
  process.exit(0);
}

main().catch((error) => {
  process.stderr.write(`[event_pre_tool_use] Error: ${error.message}\n`);
  process.exit(1);
});
```

**File 2: events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs**

Thin domain handler — all logic delegated to lib functions. Follows the "handlers are thin plumbing, ~5-10 lines of logic" principle from CONTEXT.md.

Steps:
1. Extract `toolInput` from `hookPayload.tool_input` and `toolUseId` from `hookPayload.tool_use_id`
2. Call `saveQuestionMetadata(sessionName, toolInput, toolUseId)` — saves question file for TUI driver
3. Call `formatQuestionsForAgent(toolInput, sessionName)` — builds the markdown message
4. Build `promptFilePath` = `resolve(SKILL_ROOT, 'events', 'pre_tool_use', 'ask_user_question', 'prompt_ask_user_question.md')`
5. Call `wakeAgentWithRetry({ resolvedAgent, messageContent: formattedQuestions, promptFilePath, eventType: 'PreToolUse', sessionName })` — fire-and-forget
6. Log info-level entry and return

Export a single async function `handleAskUserQuestion({ hookPayload, sessionName, resolvedAgent })`.

Imports: `resolve` from `node:path`, `SKILL_ROOT` from `../../../lib/paths.mjs`, `formatQuestionsForAgent`, `saveQuestionMetadata`, `wakeAgentWithRetry`, `appendJsonlEntry` from `../../../lib/index.mjs`.

**File 3: events/pre_tool_use/ask_user_question/prompt_ask_user_question.md**

This is the Instructions section that gets appended to the gateway message AFTER the formatted questions content. It tells the OpenClaw agent the context of this event. Keep it concise — the `formatQuestionsForAgent()` output already contains the "How to answer" instructions and the CLI call syntax. This prompt adds:

```markdown
# AskUserQuestion — Decide and Answer

Claude Code is asking you a question and waiting for your answer. The question details and options are shown above.

## Context
You are the OpenClaw orchestrating agent. You have full project context: STATE.md, ROADMAP.md, CONTEXT.md are in your conversation. Use them to make informed decisions.

## Decision Framework
- **Confirmation questions** (1-2 options, one is "yes/proceed"): Pick the affirmative. GSD doesn't hesitate.
- **Style preferences** (equivalent alternatives): Check existing codebase conventions. If uncertain, pick "You decide".
- **Scope selection** (multi-select): Select ALL items relevant to current phase. Less is not more here.
- **Architecture decisions** (options with different consequences): Cross-reference ROADMAP.md and STATE.md. Pick what aligns with project direction.
- **Open floor** (has "Something else" / "Type something"): Pick option if it matches. Type specific requirements if not.
- **Delegation** (has "You decide"): Only pick this when ALL options are equally valid AND you have no project-specific reason to prefer one.

## GSD Phase Awareness
- During `/gsd:discuss-phase`: **Full reasoning.** Your answer quality determines CONTEXT.md quality, which feeds everything downstream. Type nuanced answers, add context.
- During `/gsd:plan-phase`: **Confirm and proceed.** Unblock quickly.
- During `/gsd:execute-phase`: **Confirm and continue.** Decisions are locked in CONTEXT.md.
- Fallback: **Type something** with your reasoning. A typed reasoning is a decision — a blind first-option pick is a guess.

## Action
Read the questions above. Decide your answer per question. Call the TUI driver as shown in the instructions above.
```
  </action>
  <verify>
Run `node -e "import('./events/pre_tool_use/event_pre_tool_use.mjs')"` — must not throw import errors (will exit due to no stdin, but import must resolve).

Verify file structure: `ls events/pre_tool_use/event_pre_tool_use.mjs events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs events/pre_tool_use/ask_user_question/prompt_ask_user_question.md` — all 3 files must exist.

Verify tui-common.mjs exports: `node -e "import('./lib/tui-common.mjs').then(m => { if (!m.sendKeysToTmux || !m.sendSpecialKeyToTmux) process.exit(1); console.log('OK'); })"` — both low-level functions now exported.
  </verify>
  <done>events/pre_tool_use/ directory exists with router and AskUserQuestion subdirectory. Router dispatches by tool_name. Handler saves question metadata and wakes agent. Prompt instructs agent with decision framework and GSD phase awareness. sendKeysToTmux and sendSpecialKeyToTmux are exported from tui-common.mjs.</done>
</task>

<task type="auto">
  <name>Task 2: Create bin/tui-driver-ask.mjs — AskUserQuestion TUI navigator</name>
  <files>bin/tui-driver-ask.mjs</files>
  <action>
Create `bin/tui-driver-ask.mjs` — the AskUserQuestion-specific TUI driver, separate from `bin/tui-driver.mjs` (SRP: different inputs, different TUI patterns, different purposes). Follow the same structure as `bin/tui-driver.mjs`: shebang, parseArgs, guard clauses, async main + main().catch().

**CLI interface:**
```
node bin/tui-driver-ask.mjs --session <session-name> '<json-decisions-array>'
```
Where `<json-decisions-array>` is a JSON array with one action object per question:
```json
[
  { "action": "select", "optionIndex": 1 },
  { "action": "type", "text": "use the existing pattern" },
  { "action": "multi-select", "selectedIndices": [0, 2] },
  { "action": "chat", "text": "this question is wrong because..." }
]
```
Array index matches question tab index. One action per question.

**Main flow:**
1. Parse CLI: `--session` flag + positional JSON string (same pattern as tui-driver.mjs)
2. Validate: session required, JSON array required, each element must have `action` field
3. Read question metadata: `readQuestionMetadata(sessionName)` — if null, log error + exit 1 (PreToolUse handler must have saved it)
4. Validate: decisions array length must equal questions array length
5. Build pending answer object: map each decision to its intended answer text. For `select`: look up `questionMetadata.questions[i].options[decision.optionIndex].label`. For `type`/`chat`: use `decision.text`. For `multi-select`: look up labels for each index in `decision.selectedIndices`.
6. Save pending answer BEFORE typing: `savePendingAnswer(sessionName, pendingAnswers, decisions[0].action, questionMetadata.tool_use_id)`. Note: `action` field uses the first decision's action for single-question (most common). For multi-question, store the full decisions array as `action` field (PostToolUse comparison logic handles both).
7. Type keystrokes into tmux per action type (see navigation logic below)
8. Log info-level entry and exit 0

**TUI navigation logic (per question):**

Import `sendKeysToTmux` and `sendSpecialKeyToTmux` from `../lib/tui-common.mjs` (newly exported).

For each question at index `questionIndex` in the decisions array:

If `questionIndex > 0` in a multi-question form, send Tab key to advance to next question tab (per CONTEXT.md: "Tab auto-advances after answering each question").

**action: "select"** (Down x optionIndex, then Enter):
```javascript
function executeSelectAction(sessionName, optionIndex) {
  for (let downPress = 0; downPress < optionIndex; downPress++) {
    sendSpecialKeyToTmux(sessionName, 'Down');
  }
  sendSpecialKeyToTmux(sessionName, 'Enter');
}
```

**action: "type"** (navigate to "Type something" = Down x options.length, Enter to activate text input, type text, Enter to submit):
```javascript
function executeTypeAction(sessionName, optionCount, text) {
  // "Type something" is at position options.length (0-indexed, after all payload options)
  for (let downPress = 0; downPress < optionCount; downPress++) {
    sendSpecialKeyToTmux(sessionName, 'Down');
  }
  sendSpecialKeyToTmux(sessionName, 'Enter'); // Activate text input
  sendKeysToTmux(sessionName, text);
  sendSpecialKeyToTmux(sessionName, 'Enter'); // Submit typed text
}
```

**action: "multi-select"** (navigate to each selected index and press Space to toggle, then navigate to submit and press Enter):
```javascript
function executeMultiSelectAction(sessionName, selectedIndices, totalOptionCount) {
  // selectedIndices is sorted ascending — navigate from current position
  let currentPosition = 0;
  for (const targetIndex of [...selectedIndices].sort((a, b) => a - b)) {
    const movesNeeded = targetIndex - currentPosition;
    for (let downPress = 0; downPress < movesNeeded; downPress++) {
      sendSpecialKeyToTmux(sessionName, 'Down');
    }
    sendSpecialKeyToTmux(sessionName, 'Space');
    currentPosition = targetIndex;
  }
  // After toggling all selections, press Enter to submit
  sendSpecialKeyToTmux(sessionName, 'Enter');
}
```

**action: "chat"** (navigate below separator to "Chat about this" — position is options.length + 1 for "Type something" + 1 for separator = options.length + 2? This is LOW CONFIDENCE per CONTEXT.md — test live. For now, use options.length + 2 Down presses from position 0):
```javascript
function executeChatAction(sessionName, optionCount, text) {
  // "Chat about this" is below "Type something" (options.length) + separator
  // LOW CONFIDENCE: exact Down count needs live verification
  // Assumption: options.length + 2 (Type something + separator/Chat)
  const downPressCount = optionCount + 2;
  for (let downPress = 0; downPress < downPressCount; downPress++) {
    sendSpecialKeyToTmux(sessionName, 'Down');
  }
  sendSpecialKeyToTmux(sessionName, 'Enter'); // Activate chat input
  sendKeysToTmux(sessionName, text);
  sendSpecialKeyToTmux(sessionName, 'Enter'); // Submit chat text
}
```

**Imports:** `parseArgs` from `node:util`, `readQuestionMetadata`, `savePendingAnswer`, `appendJsonlEntry` from `../lib/index.mjs`, `sendKeysToTmux`, `sendSpecialKeyToTmux` from `../lib/tui-common.mjs` (or from index.mjs if re-exported).

**Error handling:** If question metadata file is missing, log error and exit 1 with clear message: "No question metadata found for session {sessionName}. PreToolUse handler may not have saved it." If decisions array length mismatches questions array length, log error and exit 1.
  </action>
  <verify>
Run `node -e "import('./bin/tui-driver-ask.mjs')"` — must not throw import errors (will exit due to missing --session, but imports must resolve).

Run `node bin/tui-driver-ask.mjs 2>&1 || true` — must print usage/error about missing --session flag (not an import error).

Verify file exists with shebang: `head -1 bin/tui-driver-ask.mjs` — must be `#!/usr/bin/env node`.
  </verify>
  <done>bin/tui-driver-ask.mjs exists as a standalone CLI tool. Reads question metadata from file, saves pending answer before typing, and sends correct tmux keystrokes for all 4 action types (select, type, multi-select, chat). Follows same CLI pattern as bin/tui-driver.mjs (--session flag + positional JSON).</done>
</task>

</tasks>

<verification>
1. `ls events/pre_tool_use/event_pre_tool_use.mjs events/pre_tool_use/ask_user_question/handle_ask_user_question.mjs events/pre_tool_use/ask_user_question/prompt_ask_user_question.md bin/tui-driver-ask.mjs` — all 4 files exist
2. Router handler follows guard-first pattern matching event_stop.mjs
3. Domain handler is thin (~5-10 lines logic) — all knowledge in lib/ask-user-question.mjs
4. Prompt includes decision framework with 6 question categories and GSD phase awareness
5. TUI driver validates inputs, reads question file, saves pending answer before typing
6. TUI driver implements all 4 action types with correct navigation patterns
7. sendKeysToTmux and sendSpecialKeyToTmux are now exported from tui-common.mjs
</verification>

<success_criteria>
- PreToolUse router dispatches AskUserQuestion to domain handler
- Domain handler saves question metadata and wakes agent via wakeAgentWithRetry
- Prompt instructs agent with 6-category decision framework and GSD phase awareness
- TUI driver reads question file, saves pending answer, types correct keystrokes
- All 4 action types (select, type, multi-select, chat) implemented
- No new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/04-askuserquestion-lifecycle-full-stack/04-02-SUMMARY.md`
</output>
