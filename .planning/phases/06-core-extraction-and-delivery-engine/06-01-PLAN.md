---
phase: 06-core-extraction-and-delivery-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/hook-utils.sh
autonomous: true
requirements:
  - LIB-01
  - LIB-02
  - EXTRACT-03

must_haves:
  truths:
    - "lib/hook-utils.sh contains exactly three functions: extract_last_assistant_response, extract_pane_diff, format_ask_user_questions"
    - "Each function has a single responsibility — extraction, diff computation, or question formatting"
    - "Sourcing lib/hook-utils.sh produces no side effects (no output, no variable pollution)"
    - "Per-session previous pane state is stored in /tmp/gsd-pane-prev-{SESSION_NAME}.txt with flock protection"
  artifacts:
    - path: "lib/hook-utils.sh"
      provides: "Shared extraction functions for hook scripts"
      contains: "extract_last_assistant_response"
  key_links:
    - from: "lib/hook-utils.sh"
      to: "transcript JSONL file"
      via: "tail -40 + jq type-filtered content parsing"
      pattern: "select\\(.type == \"text\"\\)"
    - from: "lib/hook-utils.sh"
      to: "/tmp/gsd-pane-prev-*.txt"
      via: "flock-protected diff with --new-line-format"
      pattern: "flock.*gsd-pane-lock"
---

<objective>
Create the shared library `lib/hook-utils.sh` with three DRY extraction functions that stop-hook.sh and pre-tool-use-hook.sh will source in subsequent plans.

Purpose: Centralise content extraction logic so both hook scripts share one fix-point for bugs and changes (DRY). Each function does exactly one thing (SRP).
Output: `lib/hook-utils.sh` — executable, sourceable, side-effect-free bash library.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-extraction-and-delivery-engine/06-RESEARCH.md
@scripts/stop-hook.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/hook-utils.sh with three extraction functions</name>
  <files>lib/hook-utils.sh</files>
  <action>
Create `lib/hook-utils.sh` with the following structure. The file starts with `#!/usr/bin/env bash` but NO `set -euo pipefail` (it is sourced, the caller sets shell options). It contains ONLY function definitions — no side effects on source.

**Function 1: `extract_last_assistant_response`**
- Takes one argument: `transcript_path` (path to JSONL file)
- If transcript_path is empty or file does not exist, echo empty string and return
- Uses `tail -40 "$transcript_path" 2>/dev/null` to read last 40 lines (constant-time, avoids reading full transcript)
- Pipes to jq with type-filtered content parsing: `jq -r 'select(.type == "assistant") | (.message.content // [])[] | select(.type == "text") | .text' 2>/dev/null`
- Pipes to `tail -1` to get only the last assistant text block
- CRITICAL: Use `select(.type == "text")` NOT `content[0].text` — positional indexing fails when thinking/tool_use blocks precede text
- CRITICAL: Add `2>/dev/null` to both tail and jq — transcript may have partial JSON line if Claude Code is mid-write
- Returns: extracted text (may be empty if extraction fails — this is intentional, triggers fallback in caller)

**Function 2: `extract_pane_diff`**
- Takes two arguments: `session_name` (tmux session name), `current_pane` (string of current pane content)
- Previous state file: `/tmp/gsd-pane-prev-${session_name}.txt`
- Lock file: `/tmp/gsd-pane-lock-${session_name}`
- Implementation pattern for flock + variable capture (avoids subshell scoping issue):
  ```
  local pane_delta
  pane_delta=$(
    flock -x -w 2 "/tmp/gsd-pane-lock-${session_name}" sh -c '
      previous_file="$1"
      if [ -f "$previous_file" ]; then
        diff --new-line-format="%L" --old-line-format="" --unchanged-line-format="" \
          "$previous_file" - 2>/dev/null || true
      fi
      cat > "$previous_file"
    ' _ "$previous_file" <<< "$current_pane"
  )
  ```
  Note: The `sh -c` child reads stdin (the current_pane via heredoc) twice: first for diff (as `-` argument), then writes it to the previous_file via `cat`. However, stdin is consumed by diff, so cat receives nothing. The correct approach is:
  ```
  pane_delta=$(
    {
      flock -x -w 2 200
      if [ -f "$previous_file" ]; then
        diff --new-line-format='%L' --old-line-format='' --unchanged-line-format='' \
          "$previous_file" <(printf '%s\n' "$current_pane") 2>/dev/null || true
      fi
      printf '%s\n' "$current_pane" > "$previous_file"
    } 200>"$lock_file"
  )
  ```
  This uses fd-based flock in a command group `{ ... }` (not a subshell `( ... )`), captured by `$()`. The `$()` is a subshell for output capture, but `pane_delta` is assigned the stdout of the whole group. The previous_file write goes to the file (not stdout), so it doesn't pollute pane_delta. Process substitution `<(printf '%s\n' "$current_pane")` provides the current pane as a file for diff comparison.
- If pane_delta is empty (first fire — no previous file, or content unchanged), fall back to last 10 lines of current_pane: `printf '%s\n' "$current_pane" | tail -10`
- Echo pane_delta

**Function 3: `format_ask_user_questions`**
- Takes one argument: `tool_input_json` (JSON string of AskUserQuestion tool_input)
- Uses jq to format each question with: question text, header (if present), multiSelect flag, numbered options with labels and descriptions
- jq filter: `.questions[] | "Question: \(.question)\n" + (if .header then "Header: \(.header)\n" else "" end) + (if .multiSelect then "Multi-select: yes\n" else "Multi-select: no\n" end) + "Options:\n" + (.options // [] | to_entries[] | "  \(.key + 1). \(.value.label)" + (if .value.description and .value.description != "" then ": \(.value.description)" else "" end)) + "\n"`
- Add `2>/dev/null || echo "(could not parse questions)"` as error fallback
- Returns: formatted question text for inclusion in wake message

Make the file executable: `chmod +x lib/hook-utils.sh`

Important conventions:
- All variable names must be self-explanatory, no abbreviations (per CLAUDE.md)
- All function names must be self-explanatory, no abbreviations (per CLAUDE.md)
- Use `printf '%s\n'` instead of `echo` when the variable might start with a dash or contain escape sequences
  </action>
  <verify>
1. `bash -n lib/hook-utils.sh` — syntax check passes with exit 0
2. `source lib/hook-utils.sh && type extract_last_assistant_response && type extract_pane_diff && type format_ask_user_questions` — all three functions are defined
3. `source lib/hook-utils.sh` produces no stdout output (no side effects)
4. `source lib/hook-utils.sh && extract_last_assistant_response ""` — returns empty string (empty path case)
5. `source lib/hook-utils.sh && extract_last_assistant_response "/nonexistent/path"` — returns empty string (missing file case)
6. `source lib/hook-utils.sh && extract_pane_diff "test-session" "line1\nline2\nline3"` — returns content (first-fire fallback: tail -10 of input)
7. `source lib/hook-utils.sh && format_ask_user_questions '{"questions":[{"question":"Pick one","options":[{"label":"A","description":"Option A"},{"label":"B","description":"Option B"}],"multiSelect":false}]}'` — returns formatted question text with numbered options
8. `test -x lib/hook-utils.sh` — file is executable
  </verify>
  <done>
lib/hook-utils.sh exists with exactly three functions (extract_last_assistant_response, extract_pane_diff, format_ask_user_questions), passes syntax validation, produces no side effects when sourced, and each function handles its error cases gracefully.
  </done>
</task>

</tasks>

<verification>
- `bash -n lib/hook-utils.sh` exits 0 (valid syntax)
- Sourcing produces no output
- All three functions are defined after source
- extract_last_assistant_response returns empty for missing/empty paths
- extract_pane_diff returns content on first fire (no previous state)
- extract_pane_diff stores state in /tmp and produces diff on second call
- format_ask_user_questions formats valid JSON input correctly
- format_ask_user_questions handles malformed JSON gracefully (returns fallback text)
</verification>

<success_criteria>
lib/hook-utils.sh exists, is executable, contains three SRP functions, passes bash -n, and all verify commands succeed. No side effects on source.
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-extraction-and-delivery-engine/06-01-SUMMARY.md`
</output>
