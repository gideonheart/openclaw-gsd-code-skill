---
phase: 06-core-extraction-and-delivery-engine
plan: 02
type: execute
wave: 2
depends_on:
  - "06-01"
files_modified:
  - scripts/pre-tool-use-hook.sh
autonomous: true
requirements:
  - ASK-01
  - ASK-02
  - ASK-03
  - WAKE-09

must_haves:
  truths:
    - "When Claude calls AskUserQuestion, Gideon receives a structured [ASK USER QUESTION] wake message with question text, options, and multiSelect flag"
    - "The PreToolUse hook never blocks the Claude Code TUI — openclaw call is always backgrounded"
    - "The PreToolUse hook always exits 0 — never denies or blocks AskUserQuestion"
    - "The hook only fires for AskUserQuestion (matcher-scoped, not all PreToolUse events)"
  artifacts:
    - path: "scripts/pre-tool-use-hook.sh"
      provides: "AskUserQuestion forwarding to OpenClaw"
      contains: "format_ask_user_questions"
  key_links:
    - from: "scripts/pre-tool-use-hook.sh"
      to: "lib/hook-utils.sh"
      via: "source statement"
      pattern: "source.*lib/hook-utils.sh"
    - from: "scripts/pre-tool-use-hook.sh"
      to: "openclaw agent"
      via: "backgrounded async call"
      pattern: "openclaw agent.*&"
---

<objective>
Create `scripts/pre-tool-use-hook.sh` — the PreToolUse hook that forwards AskUserQuestion data to OpenClaw before the TUI renders the question.

Purpose: Gideon needs to see the exact question text and options Claude is asking the user, delivered asynchronously before the user interacts with the TUI.
Output: `scripts/pre-tool-use-hook.sh` — executable bash script, registered with matcher "AskUserQuestion".
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-extraction-and-delivery-engine/06-RESEARCH.md
@.planning/phases/06-core-extraction-and-delivery-engine/06-01-SUMMARY.md
@scripts/notification-idle-hook.sh
@lib/hook-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scripts/pre-tool-use-hook.sh for AskUserQuestion forwarding</name>
  <files>scripts/pre-tool-use-hook.sh</files>
  <action>
Create `scripts/pre-tool-use-hook.sh` following the established hook script pattern from `notification-idle-hook.sh` (guard structure, debug_log, registry lookup). The script handles PreToolUse events for AskUserQuestion only.

**Structure (follows existing hook conventions):**

1. **Shebang and shell options:** `#!/usr/bin/env bash` + `set -euo pipefail`

2. **Debug logging setup:** Same pattern as other hooks — `GSD_HOOK_LOG`, `HOOK_SCRIPT_NAME`, `debug_log()` function. Log "FIRED" on entry.

3. **Section 1 — Consume stdin:** `STDIN_JSON=$(cat)` — consume immediately to prevent pipe blocking. Log byte count and hook_event_name.

4. **Section 2 — TMUX guard:** Exit 0 if `${TMUX:-}` is empty (not in tmux session).

5. **Section 3 — Extract tmux session name:** `SESSION_NAME=$(tmux display-message -p '#S' 2>/dev/null || echo "")`. Exit 0 if empty.

6. **Section 4 — Registry lookup:** Same pattern as notification-idle-hook.sh — read REGISTRY_PATH, extract AGENT_DATA, AGENT_ID, OPENCLAW_SESSION_ID. Exit 0 if not a managed session.

7. **Section 5 — Extract tool_input from stdin JSON:**
   ```bash
   TOOL_INPUT=$(printf '%s' "$STDIN_JSON" | jq -r '.tool_input // ""' 2>/dev/null || echo "")
   if [ -z "$TOOL_INPUT" ] || [ "$TOOL_INPUT" = "null" ]; then
     debug_log "EXIT: no tool_input in stdin"
     exit 0
   fi
   ```
   Log the tool_input length.

8. **Section 6 — Source lib and format questions:**
   ```bash
   SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
   source "${SCRIPT_DIR}/../lib/hook-utils.sh" 2>/dev/null || {
     debug_log "ERROR: could not source lib/hook-utils.sh"
     exit 0
   }
   FORMATTED_QUESTIONS=$(format_ask_user_questions "$TOOL_INPUT")
   ```
   Note: SCRIPT_DIR is already set from section 4 (registry path). If reusing, no need to recompute. If the section structure puts SCRIPT_DIR in section 4, reuse it here.

9. **Section 7 — Build wake message:**
   Build the v2 AskUserQuestion wake format:
   ```
   [SESSION IDENTITY]
   agent_id: ${AGENT_ID}
   tmux_session_name: ${SESSION_NAME}
   timestamp: ${TIMESTAMP}

   [TRIGGER]
   type: ask_user_question

   [ASK USER QUESTION]
   ${FORMATTED_QUESTIONS}

   [STATE HINT]
   state: awaiting_user_input

   [AVAILABLE ACTIONS]
   menu-driver.sh ${SESSION_NAME} choose <n>
   menu-driver.sh ${SESSION_NAME} type <text>
   menu-driver.sh ${SESSION_NAME} clear_then <command>
   menu-driver.sh ${SESSION_NAME} enter
   menu-driver.sh ${SESSION_NAME} esc
   menu-driver.sh ${SESSION_NAME} submit
   menu-driver.sh ${SESSION_NAME} snapshot
   ```
   Note: No [CONTEXT PRESSURE] section — not relevant for AskUserQuestion events.

10. **Section 8 — Async delivery (ALWAYS background, ALWAYS exit 0):**
    ```bash
    openclaw agent --session-id "$OPENCLAW_SESSION_ID" --message "$WAKE_MESSAGE" \
      >> "$GSD_HOOK_LOG" 2>&1 &
    debug_log "DELIVERED (async AskUserQuestion forward, bg PID=$!)"
    exit 0
    ```
    CRITICAL: No bidirectional mode for this hook. AskUserQuestion forwarding is ALWAYS async — foreground openclaw blocks the TUI before the question renders.
    CRITICAL: ALWAYS exit 0. Non-zero exit or JSON output to stdout blocks AskUserQuestion.
    CRITICAL: Do NOT echo any JSON to stdout. This hook is notification-only.

Make the file executable: `chmod +x scripts/pre-tool-use-hook.sh`

Note: This hook is matcher-scoped to "AskUserQuestion" in settings.json (Phase 7 registration concern). The script itself does not check tool_name — Claude Code only sends it PreToolUse events matching the registered matcher.

**Conventions:**
- All variable names self-explanatory, no abbreviations (per CLAUDE.md)
- Follow exact comment header style from notification-idle-hook.sh (numbered sections with `# ============================================================================`)
- Use `printf '%s'` instead of `echo` when variable might contain escape sequences
  </action>
  <verify>
1. `bash -n scripts/pre-tool-use-hook.sh` — syntax check passes with exit 0
2. `test -x scripts/pre-tool-use-hook.sh` — file is executable
3. `grep -c 'exit 0' scripts/pre-tool-use-hook.sh` — multiple exit 0 points (guards + final exit)
4. `grep 'source.*lib/hook-utils.sh' scripts/pre-tool-use-hook.sh` — sources the shared lib
5. `grep 'format_ask_user_questions' scripts/pre-tool-use-hook.sh` — calls the formatting function
6. `grep '&$' scripts/pre-tool-use-hook.sh` — openclaw call is backgrounded (ends with &)
7. `grep '\[ASK USER QUESTION\]' scripts/pre-tool-use-hook.sh` — v2 format section present
8. `grep 'type: ask_user_question' scripts/pre-tool-use-hook.sh` — correct trigger type
9. `! grep 'bidirectional' scripts/pre-tool-use-hook.sh` — no bidirectional mode (always async)
10. `! grep '"decision"' scripts/pre-tool-use-hook.sh` — no decision JSON output to stdout
  </verify>
  <done>
scripts/pre-tool-use-hook.sh exists, is executable, sources lib/hook-utils.sh, extracts tool_input from stdin, formats questions via format_ask_user_questions, builds [ASK USER QUESTION] wake message, delivers asynchronously via backgrounded openclaw call, and always exits 0.
  </done>
</task>

</tasks>

<verification>
- `bash -n scripts/pre-tool-use-hook.sh` exits 0
- Script follows established guard pattern (TMUX check, session name, registry lookup)
- Sources lib/hook-utils.sh for format_ask_user_questions
- Wake message contains [ASK USER QUESTION] section with formatted question data
- Trigger type is "ask_user_question"
- State hint is "awaiting_user_input"
- openclaw call is ALWAYS backgrounded (never foreground)
- Script ALWAYS exits 0 (never non-zero, never outputs JSON to stdout)
- No bidirectional mode branch
</verification>

<success_criteria>
pre-tool-use-hook.sh exists, is executable, passes syntax check, follows hook guard conventions, formats AskUserQuestion data via lib functions, delivers asynchronously, and always exits 0.
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-extraction-and-delivery-engine/06-02-SUMMARY.md`
</output>
